<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fussl-01: f_scheduler.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Fussl-01
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">f_scheduler.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">/*</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">* sch2.h</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">*</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">* Created: 20.03.2018 13:50:41</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">* Author: Maximilian Starke</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">*/</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//FPS: build fps, make comments better</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">/* lib description: you must not activate interrupts during the execution of some interrupt handler. this will end up in undefined behavior since somemethods, e.g. execute_interrupting_timers() assume they&#39;re always running uninterrupted. */</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">/*</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">    Watchdogs:</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">    </span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">    There are two so-called &quot;watchdogs&quot; in the context of the scheduler, the hardware watchdog and the software watchdog.</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">    With the hardware watchdog you check against exceeding atomic sections.</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment">    With the software watchdog you check against callback routines</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment">    that are scheduled but do not return in the appropriate amount of time (even if they do not use exceeding atomic sections).</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">    hardware watchdog:</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment">    The hardware watchdog / built-in watchdog of your MCU will be used by the scheduler.</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment">    You just have to tell the scheduler the hardware watchdog timeout on construction. (Therefor see the description of the constructor)</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment">    How it works internally:</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment">    The scheduler resets the built-in watchdog (implemented in hardware) on every now time update (interrupt)</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment">    so that it cannot restart the controller.</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment">    Only in case someone (the scheduler itself or the programmer using the scheduler) uses too long atomic sections</span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment">    (where interrupts are turned off) or too long interrupt handlers (..same..) the hardware watchdog will not be reseted</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment">    so it will reset the controller.</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment">    The hardware watchdog will be startet automatically when you call my_scheduler.run() and stopped if run() returns.</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment">    </span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment">    software watchdog:</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment">    With the software watchdog you check against callback routines</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment">    that are scheduled but do not return in the appropriate amount of time (even if they do not use exceeding atomic sections).</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment">    The software watchdog is a watchdog fully implemented in software by the class scheduler.</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="comment">    You may activate or deactivate the software watchdog whenever you want.</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment">    </span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment">    Having the software watchdog deactivated the following (probably undesired) scenario may occur:</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment">    There is one task that does never use atomic sections but also does not eventually return.</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">    Once this task is scheduled by the scheduler, all interrupting timers will eventually be executed</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">    but neither a non-interrupting timer nor another task will be executed anymore.</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment">    </span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="comment">    </span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="comment">*/</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="preprocessor">#ifndef __SCHEDULER_H__</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="preprocessor">#define __SCHEDULER_H__</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="preprocessor">#include &lt;stdint.h&gt;</span>         <span class="comment">// uint8_t</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="preprocessor">#include &lt;avr/wdt.h&gt;</span>        <span class="comment">// wdt_enable, wdt_disable, wdt_reset</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="preprocessor">#include &lt;math.h&gt;</span>           <span class="comment">// ceil</span></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="preprocessor">#include &quot;f_bytewise.h&quot;</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="preprocessor">#include &quot;f_callbacks.h&quot;</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="preprocessor">#include &quot;f_countdown.h&quot;</span>    <span class="comment">// software_watchdog is a fsl::lg::countdown</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="preprocessor">#include &quot;f_exceptional.h&quot;</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="preprocessor">#include &quot;f_flags.h&quot;</span>        <span class="comment">// scheduler::flags, .. flags of table line</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="preprocessor">#include &quot;f_interrupt.h&quot;</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="preprocessor">#include &quot;f_macros.h&quot;</span>       <span class="comment">// macro_interrupt_critical_begin, macro_interrupt_critical_end, macro_interrupt_critical</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="preprocessor">#include &quot;f_order.h&quot;</span>        <span class="comment">// fsl::lg::min(..) for moving parts of table when reordering</span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="preprocessor">#include &quot;f_range_int.h&quot;</span>    <span class="comment">// handle_type</span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="preprocessor">#include &quot;f_resettable.h&quot;</span>   <span class="comment">// earliest_interrupting_timer_release</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="preprocessor">#include &quot;f_system_time.h&quot;</span>  <span class="comment">// </span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="preprocessor">#include &quot;f_time.h&quot;</span>         <span class="comment">// ExtendedMetricTime</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="preprocessor">#include &quot;f_urgency.h&quot;</span>      <span class="comment">// class urgency;</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="keyword">namespace </span>fsl {</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <span class="keyword">namespace </span>os {</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        </div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        <span class="keyword">template</span> &lt;u<span class="keywordtype">int</span>8_t TABLE_SIZE, u<span class="keywordtype">int</span>8_t index_cache_size = 2&gt;</div><div class="line"><a name="l00071"></a><span class="lineno"><a class="line" href="classfsl_1_1os_1_1scheduler.html">   71</a></span>&#160;        <span class="keyword">class </span><a class="code" href="classfsl_1_1os_1_1scheduler.html">scheduler</a> {</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;            </div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;            </div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;            <span class="keyword">public</span>:     <span class="comment">/*** public types ***/</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            </div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;            <span class="keyword">using</span> <a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> = <a class="code" href="classfsl_1_1lg_1_1range__int.html">fsl::lg::range_int&lt;uint8_t,TABLE_SIZE,true,true&gt;</a>;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            </div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;            <span class="keyword">enum class</span> entry_type : uint8_t {</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                TASK = 0, TIMER = 1, INTTIMER = 2, INVALID = 255</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;            };</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;            </div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;            </div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;            <span class="keyword">public</span>:     <span class="comment">/*** public static constexpr values ***/</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            </div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;            <span class="comment">/* handle that refers to none of the entries in scheduler table */</span></div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;            <span class="keyword">static</span> constexpr <a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> NO_HANDLE{ handle_type::OUT_OF_RANGE };</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;            </div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;            <span class="comment">/* the default urgency for task entries in scheduler table */</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;            <span class="keyword">static</span> constexpr <a class="code" href="classfsl_1_1os_1_1urgency.html">urgency</a> DEFAULT_URGENCY{ urgency::normal_urgency() };</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;            </div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;            <span class="keyword">public</span>:     <span class="comment">/*** public static constexpr functions ***/</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;            </div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;            <span class="comment">/* returns size in bytes of one SchedulerMemoryLine */</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;            <span class="keyword">static</span> constexpr uint8_t table_line_size_of(){ <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(entry); }</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;            </div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;            <span class="comment">/* returns size in bytes of the whole scheduler table */</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            <span class="keyword">static</span> constexpr uint16_t table_size_of(){ <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(entry)*TABLE_SIZE; }</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            </div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            </div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;            <span class="keyword">private</span>:    <span class="comment">/*** private types ***/</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;            </div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;            <span class="comment">/* integral type used by the software watchdog countdown object */</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            <span class="keyword">using</span> software_watchdog_base_type = uint32_t;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;            </div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;            <span class="keyword">struct </span>index_cache {    <a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle;     uint8_t index;  };</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;            </div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;            <span class="comment">/* specific data only needed for tasks */</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;            <span class="keyword">struct </span>task_specifics {</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                </div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;                <a class="code" href="classfsl_1_1os_1_1urgency.html">urgency</a> task_urgency;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                </div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;                <span class="comment">/* Always the task with the smallest task_race_countdown will be executed. If this is ambiguous one of them will be executed.</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="comment">                After a task is executed task_race_countdown will be increased by urgency_inverse.</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment">                At least when a task_race_countdown would overflow if it has to be increased, all task_race_countdowns have to be shorten together.</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">                To do so, determine the min task_race_countdown and subtract this value from all task_race_countdowns.</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment">                */</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;                uint8_t task_race_countdown;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;            };</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;            <span class="comment">/* specific data only needed for timers */</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;            <span class="keyword">struct </span>timer_specifics {</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                <span class="comment">/* earliest time when timer can be executed */</span></div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;                <span class="keyword">volatile</span> <a class="code" href="classtime_1_1_extended_metric_time.html">time::ExtendedMetricTime</a>* event_time;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;            };</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;            </div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;            <span class="comment">/* class for union storage of timer / task - specific data */</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;            <span class="keyword">class </span>union_specifics {</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                <span class="keyword">private</span>:</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;                <span class="keyword">union </span>intern_union {</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;                    task_specifics task;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                    timer_specifics timer;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                    intern_union() : timer({<span class="keyword">nullptr</span>}) {}</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                };</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                intern_union _union;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;                <span class="keyword">public</span>:</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;                <span class="keyword">volatile</span> task_specifics&amp; task()<span class="keyword"> volatile </span>{ <span class="keywordflow">return</span> _union.task; }</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;                <span class="keyword">volatile</span> timer_specifics&amp; timer()<span class="keyword"> volatile </span>{ <span class="keywordflow">return</span> _union.timer; }</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;                task_specifics&amp; task() { <span class="keywordflow">return</span> _union.task; }</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                timer_specifics&amp; timer() { <span class="keywordflow">return</span> _union.timer; }</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;                </div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;                <span class="keyword">inline</span> union_specifics&amp; operator= (<span class="keyword">const</span> union_specifics&amp; rhs)              {   fsl::util::byte_copy(rhs,*<span class="keyword">this</span>);    }</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;                <span class="keyword">inline</span> union_specifics&amp; operator= (<span class="keyword">const</span> <span class="keyword">volatile</span> union_specifics&amp; rhs)     {   fsl::util::byte_copy(rhs,*<span class="keyword">this</span>);    }</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;                <span class="keyword">inline</span> <span class="keywordtype">void</span> operator= (<span class="keyword">const</span> union_specifics&amp; rhs)<span class="keyword"> volatile                 </span>{   fsl::util::byte_copy(rhs,*<span class="keyword">this</span>);    }</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;                <span class="keyword">inline</span> <span class="keywordtype">void</span> operator= (<span class="keyword">const</span> <span class="keyword">volatile</span> union_specifics&amp; rhs)<span class="keyword"> volatile        </span>{   fsl::util::byte_copy(rhs,*<span class="keyword">this</span>);    }</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;            };</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;            </div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;            <span class="comment">/* class for one scheduler line containing everything needed for one timer / task entry */</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;            <span class="keyword">struct </span>entry {</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;                <a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;                <a class="code" href="classfsl_1_1str_1_1union__callback.html">fsl::str::standard_union_callback</a> callback;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;                union_specifics specifics;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                <a class="code" href="classfsl_1_1lg_1_1flags.html">fsl::lg::single_flags</a> flags;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                </div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                entry(){}</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                <span class="keyword">inline</span> entry&amp; operator=(<span class="keyword">const</span> entry&amp; rhs) { handle = rhs.handle; callback = rhs.callback; specifics = rhs.specifics; flags = rhs.flags; }</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                <span class="keyword">inline</span> entry&amp; operator=(<span class="keyword">const</span> <span class="keyword">volatile</span> entry&amp; rhs) { handle = rhs.handle; callback = rhs.callback; specifics = rhs.specifics; flags = rhs.flags; }</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                <span class="keyword">inline</span> <span class="keywordtype">void</span> operator=(<span class="keyword">const</span> entry&amp; rhs)<span class="keyword"> volatile </span>{ handle = rhs.handle; callback = rhs.callback; specifics = rhs.specifics; flags = rhs.flags; }</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                <span class="keyword">inline</span> <span class="keywordtype">void</span> operator=(<span class="keyword">const</span> <span class="keyword">volatile</span> entry&amp; rhs)<span class="keyword"> volatile </span>{ handle = rhs.handle; callback = rhs.callback; specifics = rhs.specifics; flags = rhs.flags; }</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            };</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            </div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            </div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;            <span class="keyword">private</span>:    <span class="comment">/*** private static constexpr values ***/</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;            </div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            <span class="comment">/* flags for each scheduler entry / each scheduler table line */</span></div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;            <span class="keyword">static</span> constexpr <a class="code" href="classfsl_1_1lg_1_1range__int.html">fsl::lg::single_flags::flag_id</a> ENTRY_VALID{ 0 }; <span class="comment">// if an entry is not valid, the entry may be overwritten.</span></div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;            <span class="keyword">static</span> constexpr <a class="code" href="classfsl_1_1lg_1_1range__int.html">fsl::lg::single_flags::flag_id</a> ENTRY_ENABLED{ 1 }; <span class="comment">// if an entry is valid, then the entry will be considered on scheduling decisions iff is_enabled</span></div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;            <span class="comment">// timer will automatically be disabled right before executing, if you want the timer to execute again after a certain time, you have to re-enable its entry from inside the timer procedure.</span></div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;            <span class="comment">// And you might want to update the event_time in normal cases. To do so you can use my_handle() to get your registration handle and pass it to suitable scheduler methods.</span></div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            <span class="keyword">static</span> constexpr <a class="code" href="classfsl_1_1lg_1_1range__int.html">fsl::lg::single_flags::flag_id</a> ENTRY_TIMER{ 2 }; <span class="comment">// if entry is valid, then entry (containing unions) is treated as a timer iff IS_Timer and as task otherwise.</span></div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;            <span class="keyword">static</span> constexpr <a class="code" href="classfsl_1_1lg_1_1range__int.html">fsl::lg::single_flags::flag_id</a> ENTRY_INTERRUPTING{ 3 }; <span class="comment">// if entry is_valid and is_timer, then callback may be executed as soon as event_time is reached on system time interrupt iff IS_INTTIMER. Otherwise is has to wait until the current task/timer returned.</span></div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;            <span class="keyword">static</span> constexpr <a class="code" href="classfsl_1_1lg_1_1range__int.html">fsl::lg::single_flags::flag_id</a> ENTRY_CALLABLE{ 4 }; <span class="comment">// if entry is_valid, the callback union will be treated as a callable iff IS_CALLABLE, otherwise as function pointer.</span></div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            <span class="comment">/* flags once for every scheduler object */</span></div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;            <span class="keyword">static</span> constexpr <a class="code" href="classfsl_1_1lg_1_1range__int.html">fsl::lg::single_flags::flag_id</a> RUNNING{ 0 }; <span class="comment">// true iff run() runs // write access only by run()</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;            <span class="keyword">static</span> constexpr <a class="code" href="classfsl_1_1lg_1_1range__int.html">fsl::lg::single_flags::flag_id</a> STOP_CALLED{ 1 }; <span class="comment">// if true, run() should return when current task returns.</span></div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;            <span class="comment">// if it is true no int timers will be executed anymore until scheduler was started again.</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;            <span class="keyword">static</span> constexpr <a class="code" href="classfsl_1_1lg_1_1range__int.html">fsl::lg::single_flags::flag_id</a> SOFTWARE_INTERRUPTS_ENABLE{ 2 }; <span class="comment">// scheduler will only look for int timers at now time update if enabled</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            <span class="keyword">static</span> constexpr <a class="code" href="classfsl_1_1lg_1_1range__int.html">fsl::lg::single_flags::flag_id</a> EMPTY_TABLE_DETECTED{ 3 }; <span class="comment">// for function-local internal use in run() only.</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;            <span class="keyword">static</span> constexpr <a class="code" href="classfsl_1_1lg_1_1range__int.html">fsl::lg::single_flags::flag_id</a> ONE_INTERRUPT_TIMER_ONLY{ 4 }; <span class="comment">// for function-local internal use in run() only.</span></div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                <span class="comment">// set and reset of this flag must be available for one from the outside. #########</span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;            </div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;            </div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;            <span class="keyword">private</span>:    <span class="comment">/*** private static constexpr fucntions ***/</span></div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;            <span class="comment">/* {0, 1, .. , TABLE_SIZE - 1} -&gt; {0, 1, .. , TABLE_SIZE - 1} : x |-&gt; (x - 1) mod TABLE_SIZE */</span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;            <span class="keyword">inline</span> <span class="keyword">static</span> constexpr uint8_t minus_one_mod_table_size(uint8_t uint){</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                <span class="keywordflow">return</span> static_cast&lt;uint8_t&gt;( (static_cast&lt;uint16_t&gt;(uint) + static_cast&lt;uint16_t&gt;(TABLE_SIZE -1)) % static_cast&lt;uint16_t&gt;(TABLE_SIZE) );</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;            }</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;            </div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;            <span class="keyword">private</span>:    <span class="comment">/*** private data ***/</span></div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            </div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;            <span class="comment">/* the scheduler object&#39;s flags */</span></div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;            <span class="keyword">volatile</span> <a class="code" href="classfsl_1_1lg_1_1flags.html">fsl::lg::single_flags</a> flags;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;            </div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;            <span class="comment">/* handle of currently running callback method&#39;s corresponding entry in scheduler table. */</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;            <span class="keyword">volatile</span> <a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> callback_handle;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            </div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            <span class="comment">/* table containing all timers and tasks</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="comment">            table layout definition:</span></div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="comment">            0               :   interrupting timers [no gap]    :   VALID</span></div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="comment">            :   non-interrupting timers         :   VALID</span></div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="comment">            :   [maybe gap]                     :  INVALID</span></div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="comment">            :   tasks [no gap]                  :   VALID</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="comment">            TABLE_SIZE      :</span></div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="comment">            </span></div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="comment">            </span></div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="comment">            About the entries&#39; flags:</span></div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="comment">            An entry is gap if and only if not IS_VALID.</span></div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="comment">            An entry with IS_VALID but not IS_ENABLED is not gap and has to be inside its section,</span></div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="comment">            although it will not be treated by the scheduler since is is so-called disabled.</span></div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="comment">            </span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="comment">            Access to table:</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="comment">            You must always leave the scheduler table in a layout-definition conform and non corrupted state.</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="comment">            For modifying you must put any operation inside an maro_interrupt_critical() - environment (atomic section) if you are not the interrupt yourself.</span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="comment">            Of course reading the table won&#39;t disturb the table content anyway, but also reading should be done in atomic sections,</span></div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="comment">            since otherwise there is no particular guaranty for reading from a consistent table, since anyone could interrupt you and modify the table,</span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="comment">            even while you read one multi-byte datum.</span></div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;            <span class="keyword">volatile</span> entry table[TABLE_SIZE];</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            <span class="comment">// see: https://www.mikrocontroller.net/articles/AVR-GCC-Tutorial/Der_Watchdog</span></div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;            <span class="comment">/* timeout value for initialization of hardware watchdog</span></div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="comment">            must be greater than the time between two now time updates</span></div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="comment">            must be set to one of the predefined macro constans from avr/wdt.h like WDTO_15MS, WDTO_30MS, ... </span></div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="comment">            initialized via ctor</span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;            uint8_t hardware_watchdog_timeout; <span class="comment">// really used in no interrupt environment ???? &lt;&lt;&lt;&lt;&lt;&lt; missing volatile</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;            </div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;            <span class="comment">/* software_watchdog.value() is a value proportional to the time which passes until the software watchdog &quot;resets the controller&quot;,</span></div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;<span class="comment">            i.e. stops to reset the hardware watchdog with wdt_reset().</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="comment">            exactly spoken, the value is the number of time_update_interrupt_handler() calls left until sw watchdog triggers controller reset.</span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="comment">            software_watchdog.reset() must be called on finishing of any non-interrupting called task or timer procedure.</span></div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="comment">            software_watchdog.count_down() must be called on every SysTime interrupt / now_time_update.</span></div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;<span class="comment">            software_watchdog.XXX_reset_value() {get, set} represents the number of now time updates between fresh reset and trigger of reboot.</span></div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="comment">            If and only if reset_value is 0 the software_watchdog is disabled.</span></div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="comment">            Notice in this case that watchdog runs in background to observe behavior of scheduler and of too long interrupt callbacks.</span></div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="comment">            */</span>          </div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;            <span class="keyword">volatile</span> <a class="code" href="classfsl_1_1lg_1_1countdown.html">fsl::lg::countdown&lt;software_watchdog_base_type&gt;</a> software_watchdog;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;            </div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;            <span class="comment">/* event time of the enabled interrupt timer with the smallest event time.</span></div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="comment">            on construction of scheduler it must be set to EMT::MIN()</span></div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="comment">            Whenever a new interrupt timers has been added or an existing one has been enabled, it must be updated to min(old, new_int_timer.event_time) */</span></div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;            <span class="comment">//volatile fsl::str::resettable&lt;time::ExtendedMetricTime, 0&gt; earliest_interrupting_timer_release; // &lt;&lt;&lt;&lt; not possible </span></div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;            <span class="keyword">volatile</span> <a class="code" href="classtime_1_1_extended_metric_time.html">time::ExtendedMetricTime</a> earliest_interrupting_timer_release;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;            </div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;            </div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;            <span class="keyword">private</span>:    <span class="comment">/*** private methods ***/</span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;            </div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;            </div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;            <span class="comment">/* sets earliest_interrupting_timer_release to the min of earliest_interrupting_timer_release and t</span></div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="comment">               to be called if you enable an interrupting timer or change it&#39;s execution time */</span></div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> adjust_earliest_interrupting_timer_release(<span class="keyword">const</span> <a class="code" href="classtime_1_1_extended_metric_time.html">time::ExtendedMetricTime</a> t){ <span class="keywordflow">if</span> (t &lt; earliest_interrupting_timer_release) earliest_interrupting_timer_release = t; }</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            </div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            <span class="comment">/* returns index of table where given handle can be found</span></div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="comment">            only call from inside an atomic section</span></div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="comment">            returns TABLE_SIZE iff there is no valid entry with given handle */</span></div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;            <span class="keyword">inline</span> uint8_t get_index_uncached (<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;                uint16_t candidate = handle;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;                <span class="keywordflow">for</span> (uint8_t i = 0; i &lt; (TABLE_SIZE + 1) /2; ++i){</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;                    <span class="keywordflow">if</span> ((table[(candidate + i) % TABLE_SIZE].handle == handle) &amp;&amp; (table[(candidate + i) % TABLE_SIZE].flags.get(ENTRY_VALID))) <span class="keywordflow">return</span> (candidate + i) % TABLE_SIZE;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;                    <span class="keywordflow">if</span> ((table[(candidate + TABLE_SIZE - i - 1) % TABLE_SIZE].handle == handle) &amp;&amp; (table[(candidate + TABLE_SIZE - i - 1) % TABLE_SIZE].flags.get(ENTRY_VALID))) <span class="keywordflow">return</span> (candidate + TABLE_SIZE - i - 1) % TABLE_SIZE;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                }</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                <span class="keywordflow">return</span> TABLE_SIZE; <span class="comment">// there is no such entry</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;            }</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            </div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;            <span class="keyword">private</span>:</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;            index_cache get_index_cache[index_cache_size];</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;            <span class="keyword">public</span>:</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;            <span class="comment">/* returns index of table where given handle can be found</span></div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="comment">            only call from inside an atomic section</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment">            returns TABLE_SIZE iff there is no valid entry with given handle */</span></div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;            uint8_t get_index(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                index_cache* cache{ get_index_cache }; <span class="comment">//### remove alias</span></div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                <span class="keywordflow">for</span>(uint8_t i = 0; i &lt; index_cache_size; ++i){</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                    <span class="keywordflow">if</span> ((cache[i].handle == handle) &amp;&amp; (table[cache[i].index].handle == handle)){</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                        <span class="keyword">const</span> uint8_t index{ cache[i].index };</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                        <span class="keywordflow">if</span> (i != 0) { <span class="comment">// push nearer to front</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;                            fsl::util::byte_swap(cache[i], cache[i-1]); <span class="comment">//### change back to byte_swap!!!</span></div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;                        }</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                        <span class="keywordflow">return</span> index; </div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;                    }</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                }</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                uint8_t index = get_index_uncached(handle);</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;                <span class="keywordflow">if</span> (index == TABLE_SIZE) <span class="keywordflow">return</span> TABLE_SIZE;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;                <span class="keywordflow">for</span> (uint8_t i = index_cache_size - 1; i &gt; 1; ++i){</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;                    cache[i] = cache[i-1];</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;                }</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                cache[0].index = index;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;                cache[0].handle = handle;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                <span class="keywordflow">return</span> index;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;            }</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;            </div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;            <span class="comment">/* executes a callback. if callback pointer is nullptr, nothing will be done */</span></div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;            <span class="comment">/* if (cimota) interrupts will be activated before procedure call and deactivated after procedure call */</span></div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;            <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> cimota&gt;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> execute_callback(<a class="code" href="classfsl_1_1str_1_1union__callback.html">fsl::str::standard_union_callback</a> callback, <span class="keywordtype">bool</span> is_callable){</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                <span class="keywordflow">if</span> (cimota) sei(); <span class="comment">// replace with the future lite_cimota implementation!</span></div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                (is_callable) ? callback.call_callable() : callback.call_function();</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;                <span class="keywordflow">if</span> (cimota) cli();</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                }</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;            </div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;            <span class="comment">/* executes callback of given table index.</span></div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;<span class="comment">            The callback will automatically be checked if it is nullptr, in this case nothing will be done</span></div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="comment">            Make sure that table is non-volatile during function call - You should own table inside an atomic section or you should be any direct or indirect subroutine of ISR. */</span></div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;            <span class="comment">/* if (cimota) interrupts will be activated before procedure call and deactivated after procedure call */</span></div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;            <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> cimota&gt;</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> execute_callback(uint8_t table_index){</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                <span class="keywordflow">return</span> execute_callback&lt;cimota&gt;(table[table_index].callback,table[table_index].flags.get(ENTRY_CALLABLE));</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;            }</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;            <span class="comment">// both functions are never used with cimota != false</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;            </div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;            <span class="comment">/* first checks earliest_interrupting_timer_release whether following stuff must be done:</span></div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="comment">            goes through all (valid) int timer entries and executes the callback if execution_time expired and entry is enabled.</span></div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="comment">            Method must not be interrupted during its execution. It does not explicitly turns off interrupts since it should only be called as interrupt subroutine.</span></div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;<span class="comment">            So it assumes to always run uninterrupted</span></div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;<span class="comment">            returns false:  earliest_time was not reached, no iteration through table, no callback executed</span></div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;<span class="comment">            returns true:   algorithm went through table, probably executing at least one callback (if earliest_interrupting_timer_release was not earlier than what it should mean), and earliest_interrupting_timer_release was updated.</span></div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">bool</span> execute_interrupting_timers(){</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                <a class="code" href="classtime_1_1_extended_metric_time.html">time::ExtendedMetricTime</a> now = fsl::os::system_time::get_instance()();</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                <span class="keywordflow">if</span> (now &lt; earliest_interrupting_timer_release)      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;                <a class="code" href="classtime_1_1_extended_metric_time.html">time::ExtendedMetricTime</a> new_earliest_interrupting_timer_release = time::ExtendedMetricTime::MAX();</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;                </div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                <span class="comment">/* @when here:</span></div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="comment">                We must check for expired int timers and update earliest_interrupting_timer_release</span></div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="comment">                because earliest_interrupting_timer_release expired.</span></div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="comment">                We exspect the table to be in a consistent state.</span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="comment">                */</span></div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                uint8_t index = 0;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                </div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                <span class="keywordflow">while</span>(index &lt; TABLE_SIZE){</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                    <span class="keywordflow">if</span> ((table[index].flags.get(ENTRY_VALID) == <span class="keyword">false</span>) || (table[index].flags.get(ENTRY_TIMER) == <span class="keyword">false</span>) || (table[index].flags.get(ENTRY_INTERRUPTING) == <span class="keyword">false</span>)){ <span class="comment">// end of int-timer section</span></div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                        <span class="keywordflow">break</span>;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                    }</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                    <span class="comment">// @when here: at [index] we see a valid entry that is of type int-timer.</span></div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;                    <span class="keywordflow">if</span> (table[index].flags.get(ENTRY_ENABLED)){</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                        <span class="keywordflow">if</span> (now &gt;= *table[index].specifics.timer().event_time){</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                            table[index].flags.set_false(ENTRY_ENABLED);</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;                            <a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> local_stack = callback_handle;</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;                            callback_handle = table[index].handle;</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;                            execute_callback&lt;false&gt;(index);</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;                            callback_handle = local_stack;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;                            <span class="keywordflow">if</span> (flags.get(ONE_INTERRUPT_TIMER_ONLY)){</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                                <span class="comment">// prevention against some infinite loop of executing int timers. Next timer should wait for next now_time_update.</span></div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;                                <span class="comment">// earliest_interrupting_timer_release is still in the past.</span></div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;                                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;                            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;                                <span class="comment">// start from begin again, because table might be modified by callback procedure.</span></div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                                index = 0;</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                                <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;                            }</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                            <span class="comment">// &lt;&lt;&lt; one of those two strategies must be chosen.</span></div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;                        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                            <span class="keywordflow">if</span> (new_earliest_interrupting_timer_release &gt; *table[index].specifics.timer().event_time){ <span class="comment">// if found smaller one then replace</span></div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;                                new_earliest_interrupting_timer_release = *table[index].specifics.timer().event_time;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;                            }</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;                        }</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;                    }</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;                    ++index;</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;                }</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;                <span class="comment">/*@ reached end of int timer section, all expired timers executed */</span></div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;                earliest_interrupting_timer_release = new_earliest_interrupting_timer_release;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;            }</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;            </div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;            <span class="comment">/* get entry type of given handle. only call from inside an atomic section */</span></div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;            <span class="keyword">inline</span> entry_type get_entry_type_unsave(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;                uint8_t index = get_index(handle);</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;                <span class="keywordflow">if</span> (index == TABLE_SIZE) <span class="keywordflow">return</span> entry_type::INVALID;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;                <span class="keywordflow">return</span> table[index].flags.get(ENTRY_TIMER) ? (table[index].flags.get(ENTRY_INTERRUPTING) ? entry_type::INTTIMER : entry_type::TIMER) : entry_type::TASK;</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;            }</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;            </div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;            <span class="comment">/* prepares an unused (= not IS_VALID) line to add a new task or timer or int-timer there</span></div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;<span class="comment">            returns TABLE_SIZE if the table is full. In this case the table is not changed</span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="comment">            otherwise returns the index of the line which was prepared.</span></div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;<span class="comment">            The prepared line comes with a free handle stored inside this line.</span></div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;<span class="comment">            It is already marked as IS_VALID, as task / timer / int-timer as given in parameters and as not IS_ENABLED</span></div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;<span class="comment">            only call from inside of a critical_section which is already save against interrupts</span></div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;            uint8_t new_table_line(<span class="keywordtype">bool</span> is_task, <span class="keywordtype">bool</span> is_interrupting){</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;                <span class="comment">/* is_task :&lt;=&gt; false for any timer type, true for any task, is_interrupting: irrelevant for any task */</span></div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;                <span class="comment">/* search for invalid entry to replace: */</span></div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;                uint8_t index;</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;                <span class="comment">// we look from max index to min when we want to add a new task, because of table layout [int timer, timer, gaps, tasks]</span></div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;                <span class="comment">// we look from min index to max when we want to add a new timer, because of table layout.</span></div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;                <span class="keywordflow">for</span>(index = is_task * (TABLE_SIZE -1); (index &lt; TABLE_SIZE); is_task ? --index : ++index){</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;                    <span class="keywordflow">if</span> (table[index].flags.get(ENTRY_VALID) == <span class="keyword">false</span>) <span class="keywordflow">goto</span> found_invalid_entry;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;                }</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;                <span class="comment">/*@when here: The table is already full */</span></div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;                <span class="keywordflow">return</span> TABLE_SIZE;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;                </div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;                found_invalid_entry:</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;                uint8_t free_index{ index };</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                <span class="comment">/*@when here: The table has a free line, we stored that index as free_index,</span></div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;<span class="comment">                there must be also a free handle since there is at least one free line in the table */</span></div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;                <a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> free_handle{ NO_HANDLE };</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                </div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                <span class="comment">// search for free handle</span></div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;                constexpr uint8_t c_candidates{ 3 };</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;                <a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> candidates[c_candidates] = {<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a>(index), table[index].handle, <a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a>((index + 1) % TABLE_SIZE)};</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;                </div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;                <span class="comment">/* strategies:</span></div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="comment">                </span></div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;<span class="comment">                1:  prefer handle == index in table:</span></div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;<span class="comment">                update rule on found forbidder: decrement</span></div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;<span class="comment">                description: task index may grow up, timer index my become smaller during handler life, when task with greater / timer with smaller index is deleted</span></div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;<span class="comment">                </span></div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="comment">                2:  handle = handle of last entry that was written here.</span></div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="comment">                update rule on found forbidder: new index = index of conflict, i.e. index of the forbidder.</span></div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="comment">                description: because this handle is possibly free since the entry was marked disabled</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="comment">                </span></div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="comment">                3:  [same like 1, but different update strategy]</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;<span class="comment">                prefer handle == index in table:</span></div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;<span class="comment">                update rule on found forbidder: increment</span></div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;<span class="comment">                description: task index may grow up, timer index my become smaller during handler life, when task with greater / timer with smaller index is deleted</span></div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;<span class="comment">                </span></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;<span class="comment">                */</span></div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;                uint8_t check_until_index[c_candidates] = {index, index, index};</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;                </div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;                <span class="keywordflow">while</span> (<span class="keyword">true</span>){</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;                    index = (index + 1) % TABLE_SIZE; <span class="comment">// increment table index</span></div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;                    <span class="comment">// check that there is no crash between candidate and the current line:</span></div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;                    <span class="keywordflow">if</span> (table[index].flags.get(ENTRY_VALID)){ <span class="comment">// if current line is valid, any candidate must not equal the current line&#39;s handle.</span></div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;                        <span class="keywordflow">for</span>(uint8_t i = 0; i &lt; c_candidates; ++i){</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;                            <span class="keywordflow">if</span> (table[index].handle == candidates[i]){</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;                                <span class="comment">// candidate is already used at current index, use different update strategies for candidates:</span></div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;                                <span class="keywordflow">if</span> (i == 0){</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;                                    <span class="comment">// idea: go through all possible handles by moving --</span></div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;                                    candidates[i] = minus_one_mod_table_size(candidates[i]);</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;                                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i == 1){</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;                                    <span class="comment">// idea: if we wanted an handle that equals it&#39;s entry&#39;s index but we found this forbidder here, try the forbidders index</span></div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;                                    candidates[i] = index;</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;                                    } <span class="keywordflow">else</span> { <span class="comment">/* (i == 2) */</span></div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;                                    <span class="comment">//idea: just go ++, opposite direction compared to case (i == 0)</span></div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;                                    candidates[i] = (static_cast&lt;uint8_t&gt;(candidates[i]) + 1) % TABLE_SIZE; <span class="comment">// &lt;&lt;&lt; should candidates rather be array of uint8_t????</span></div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                                }</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;                                check_until_index[i] = minus_one_mod_table_size(index);</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;                            }</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;                        }</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;                    }</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;                    <span class="comment">// look whether there is a candidate for that we have a proof that it is indeed unused.</span></div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;                    <span class="keywordflow">for</span>(uint8_t i = 0; i &lt; c_candidates; ++i){</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;                        <span class="keywordflow">if</span> (check_until_index[i] == index){</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;                            <span class="comment">// this candidate is a free handle</span></div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;                            free_handle = candidates[i];</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;                            <span class="keywordflow">goto</span> found_free_handle;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;                        }</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;                    }</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;                }</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;                </div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;                found_free_handle:</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;                <span class="comment">/* @when here: free_index is an index of an unused line, free_handle is an unused handle.</span></div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;<span class="comment">                if we want to create an interrupting timer we need to swap position with first non_int timer</span></div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;<span class="comment">                if we want to create a task or a non-int timer, then free_index is already in the right table section.</span></div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;<span class="comment">                */</span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;                <span class="keywordflow">if</span> ((!is_task) &amp;&amp; (is_interrupting)){ <span class="comment">// we need to swap a new int timer line to the section of int timers!</span></div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;                    <span class="comment">// Check whether predecessors of our int-timer are non-int timers.</span></div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;                    <span class="keywordflow">for</span>(index = free_index; <span class="keyword">true</span>; --index ){ <span class="comment">// check about a swap of index and free_index</span></div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;                        <span class="keywordflow">if</span> ((index == 0) || (table[index-1].flags.get(ENTRY_INTERRUPTING))) <span class="keywordflow">break</span>; <span class="comment">// swap with current index</span></div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;                    }</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;                    <span class="comment">// we need to swap:</span></div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;                    <span class="comment">// move from index to free_index</span></div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;                    </div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;                    <span class="comment">// if (free_index != index):</span></div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;                    table[free_index] = table[index]; </div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;                    free_index = index;</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;                }</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;                table[free_index].handle = free_handle;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;                table[free_index].flags.set_true(ENTRY_VALID);</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;                table[free_index].flags.set(ENTRY_TIMER, ! is_task);</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;                table[free_index].flags.set(ENTRY_INTERRUPTING, is_interrupting);</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;                table[free_index].flags.set_false(ENTRY_ENABLED);</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;                <span class="keywordflow">return</span> free_index;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;            }</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;            </div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;            <span class="comment">// &lt;&lt;&lt;&lt;&lt; maybe offer a second, unsave version</span></div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;            <span class="comment">/* activate hardware watchdog and set the timeout to hardware_watchdog_timeout */</span></div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> activate_hardware_watchdog(){</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;                macro_interrupt_critical(</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;                wdt_enable(hardware_watchdog_timeout);</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;                wdt_reset();</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;                );</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;            }</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;            </div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;            <span class="comment">// &lt;&lt;&lt;&lt;&lt;&lt; maybe offer a second, unsave version</span></div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;            <span class="comment">/* deactivate hw watchdog */</span></div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> deactivate_hardware_watchdog(){</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;                macro_interrupt_critical(</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;                wdt_disable();</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;                );</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;            }</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;            </div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;            </div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;            <span class="keyword">public</span>:     <span class="comment">/*** public constructor ***/</span></div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;            </div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;            <span class="comment">/* for hardware_watchdog_timeout use the predefined macros from avr/wdt.h like WDTO_15MS, WDTO_30MS, ... or consult your MCUs data sheet. */</span></div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;            <span class="comment">/* the value must be greater than the time between two now time updates. */</span></div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;            <span class="comment">//### bad description</span></div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classfsl_1_1os_1_1scheduler.html">scheduler</a>(<span class="keywordtype">bool</span> software_interrupt_enable, uint8_t hardware_watchdog_timeout, <span class="keyword">const</span> <a class="code" href="classtime_1_1_extended_metric_time.html">time::ExtendedMetricTime</a>&amp; watchdog) : </div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;                flags(0), callback_handle(NO_HANDLE), hardware_watchdog_timeout(hardware_watchdog_timeout), earliest_interrupting_timer_release(time::ExtendedMetricTime::MIN()) {</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;                clear_table();</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;                activate_software_watchdog(watchdog);</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;                }</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;            </div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;            </div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;            <span class="keyword">public</span>:     <span class="comment">/*** public methods ***/</span></div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;            </div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;            <span class="comment">/* activate software interrupts / activate interrupting timers</span></div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;<span class="comment">            notice that these functions will also be executed, but only by non-interrupting calls */</span></div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;            <span class="keywordtype">void</span> enable_software_interrupts(){ macro_interrupt_critical( flags.set_true(SOFTWARE_INTERRUPTS_ENABLE);); }</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;            <span class="comment">/* deactivate software interrupts / deactivate interrupting timers</span></div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;<span class="comment">            notice that these functions will also be executed, but only by non-interrupting calls */</span></div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;            <span class="keywordtype">void</span> disable_software_interrupts(){ macro_interrupt_critical( flags.set_false(SOFTWARE_INTERRUPTS_ENABLE);); }</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;            </div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> my_handle(){ <span class="keywordflow">return</span> callback_handle; }</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;            </div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_running(){ <span class="keywordflow">return</span> flags.get(RUNNING); }</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;            </div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">bool</span> was_stop_called(){ <span class="keywordflow">return</span> flags.get(STOP_CALLED); }</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;            </div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;            <span class="comment">/* get entry type of given handle */</span></div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;            <span class="keyword">inline</span> entry_type get_entry_type(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;                entry_type result;</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;                macro_interrupt_critical( result = get_entry_type_unsave(handle); );</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;                <span class="keywordflow">return</span> result;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;            }</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;            </div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;            <span class="comment">/* set task_race_countdown to 0. The task will be executed at least before any task that has race_countdown &gt; 0.</span></div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;<span class="comment">            returns     0:  reset done without any errors</span></div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;<span class="comment">            1:  invalid handle, nothing done</span></div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;<span class="comment">            2:  handle is associated with a timer / int-timer entry</span></div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;            uint8_t push_task_to_front(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;                uint8_t error_code{ 0 };</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;                macro_interrupt_critical(</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;                uint8_t index = get_index(handle);</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;                <span class="keywordflow">if</span> (index == TABLE_SIZE) error_code = 1;</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;                <span class="keywordflow">if</span> (!error_code){</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;                    <span class="keywordflow">if</span> (table[index].flags.get(ENTRY_TIMER)) error_code = 2;</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;                }</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;                <span class="keywordflow">if</span> (!error_code) table[index].specifics.task().task_race_countdown = 0;</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;                );</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;                <span class="keywordflow">return</span> error_code;</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;            }</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;            <span class="comment">/* &lt;&lt;&lt;&lt;&lt;&lt;</span></div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;<span class="comment">            duplicate description: $598</span></div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;<span class="comment">            We may use accessor object in future versions to avoid multiple duplications of </span></div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;<span class="comment">                uint8_t error_code{ 0 };</span></div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;<span class="comment">                macro_interrupt_critical(</span></div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;<span class="comment">                uint8_t index = get_index(handle);</span></div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;<span class="comment">                if (index == TABLE_SIZE) error_code = 1;</span></div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;<span class="comment">                ...</span></div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;<span class="comment">            accessor classes may be derived from an atomic class</span></div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;<span class="comment">            </span></div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;            </div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;            <span class="comment">/* set task_urgency_inverse. This value must not be 0. 0 will replaced by 1.</span></div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;<span class="comment">            returns     0:  done without any errors</span></div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;<span class="comment">            1:  invalid handle, nothing done</span></div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;<span class="comment">            2:  handle is associated with a timer / int-timer entry</span></div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;            uint8_t set_task_urgency(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle, <a class="code" href="classfsl_1_1os_1_1urgency.html">urgency</a> urg){</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;                uint8_t error_code{ 0 };</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;                macro_interrupt_critical( <span class="comment">// duplicate: see push_task_to_front $598</span></div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;                uint8_t index = get_index(handle);</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;                <span class="keywordflow">if</span> (index == TABLE_SIZE) error_code = 1;</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;                <span class="keywordflow">if</span> (!error_code){</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;                    <span class="keywordflow">if</span> (table[index].flags.get(ENTRY_TIMER)) error_code = 2;</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;                }</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;                <span class="keywordflow">if</span> (!error_code) table[index].specifics.task().task_urgency = urg;</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;                );</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;                <span class="keywordflow">return</span> error_code;</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;            }</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;            </div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;            <span class="comment">/* reset task_urgency_inverse to standard urgency.</span></div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;<span class="comment">            returns     0:  done without any errors</span></div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<span class="comment">            1:  invalid handle, nothing done</span></div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;<span class="comment">            2:  handle is associated with a timer / int-timer entry</span></div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;            uint8_t reset_task_urgency_inverse(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;                uint8_t error_code{ 0 };</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;                macro_interrupt_critical( <span class="comment">// duplicate: see push_task_to_front $598</span></div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;                uint8_t index = get_index(handle);</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;                <span class="keywordflow">if</span> (index == TABLE_SIZE) error_code = 1;</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;                <span class="keywordflow">if</span> (!error_code){</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;                    <span class="keywordflow">if</span> (table[index].flags.get(ENTRY_TIMER)) error_code = 2;</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;                }</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;                <span class="keywordflow">if</span> (!error_code) table[index].specifics.task().urgency_inverse = DEFAULT_URGENCY;</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;                );</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;                <span class="keywordflow">return</span> error_code;</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;            }</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;            </div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;            <span class="comment">/* increase task_urgency / decrease_task_urgency_inverse.</span></div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;<span class="comment">            returns     0:  done without any errors</span></div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;<span class="comment">            1:  invalid handle, nothing done</span></div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;<span class="comment">            2:  handle is associated with a timer / int-timer entry</span></div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;            uint8_t increase_task_urgency(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;                uint8_t error_code{ 0 };</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;                macro_interrupt_critical(<span class="comment">// duplicate: see push_task_to_front $598</span></div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;                uint8_t index = get_index(handle);</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;                <span class="keywordflow">if</span> (index == TABLE_SIZE) error_code = 1;</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;                <span class="keywordflow">if</span> (!error_code){</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;                    <span class="keywordflow">if</span> (table[index].flags.get(ENTRY_TIMER)) error_code = 2;</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;                }</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;                <span class="keywordflow">if</span> (!error_code) table[index].specifics.task().increase_urgency();</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;                );</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;                <span class="keywordflow">return</span> error_code;</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;            }</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;            <span class="comment">/* decrease task_urgency / increase_task_urgency_inverse.</span></div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;<span class="comment">            returns     0:  done without any errors</span></div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;<span class="comment">            1:  invalid handle, nothing done</span></div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;<span class="comment">            2:  handle is associated with a timer / int-timer entry</span></div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;            uint8_t decrease_task_urgency(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;                uint8_t error_code{ 0 };</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;                macro_interrupt_critical(<span class="comment">// duplicate: see push_task_to_front $598</span></div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;                uint8_t index = get_index(handle);</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;                <span class="keywordflow">if</span> (index == TABLE_SIZE) error_code = 1;</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;                <span class="keywordflow">if</span> (!error_code){</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;                    <span class="keywordflow">if</span> (table[index].flags.get(ENTRY_TIMER)) error_code = 2;</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;                }</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;                <span class="keywordflow">if</span> (!error_code) table[index].specifics.task().decrease_urgency();</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;                );</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;                <span class="keywordflow">return</span> error_code;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;            }</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;            </div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;            <span class="comment">/* Set callback of entry associated with given handle.</span></div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;<span class="comment">            returns 0 if successful, returns 1 if handle does not meet a valid entry. */</span></div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;            <span class="keyword">inline</span> uint8_t set_callback(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle, decltype(<span class="keyword">nullptr</span>) callback){    <span class="keywordflow">return</span> reset_callback(handle,fsl::str::void_function(<span class="keyword">nullptr</span>)); }</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;            </div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;            <span class="comment">/* Set callback of entry associated with given handle.</span></div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;<span class="comment">            returns 0 if successful, returns 1 if handle does not meet a valid entry. */</span></div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;            <span class="keyword">inline</span> uint8_t set_callback(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle, fsl::str::void_function callback){</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;                macro_interrupt_critical_begin; <span class="comment">// duplicate: see push_task_to_front $598</span></div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;                uint8_t index = get_index(handle);</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;                <span class="keywordflow">if</span> (index == TABLE_SIZE) {</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;                    macro_interrupt_critical_end;</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;                    <span class="keywordflow">return</span> 1;</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;                }</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;                table[index].callback.set_function_ptr(callback);</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;                table[index].flags.set_false(ENTRY_CALLABLE);</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;                macro_interrupt_critical_end;</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;                <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;            }</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;            </div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;            <span class="comment">/* Set callback of entry associated with given handle.</span></div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;<span class="comment">            returns 0 if successful, returns 1 if handle does not meet a valid entry. */</span></div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;            <span class="keyword">inline</span> uint8_t set_callback(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle, <a class="code" href="classfsl_1_1str_1_1callable.html">fsl::str::callable</a>* callback){</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;                macro_interrupt_critical_begin;<span class="comment">// duplicate: see push_task_to_front $598</span></div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;                uint8_t index = get_index(handle);</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;                <span class="keywordflow">if</span> (index == TABLE_SIZE) {</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                    macro_interrupt_critical_end;</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;                    <span class="keywordflow">return</span> 1;</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;                }</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;                table[index].callback.set_callable_ptr(callback);</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;                table[index].flags.set_true(ENTRY_CALLABLE);</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;                macro_interrupt_critical_end;</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;                <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;            }</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;            </div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;            <span class="comment">/* set callback procedure to nullptr */</span></div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;            <span class="keyword">inline</span> uint8_t reset_callback(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){ <span class="keywordflow">return</span> set_callback(handle,<span class="keyword">nullptr</span>); }</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;            </div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;            <span class="comment">/* Write the associated standard_union_callback into callback, set is_callable flag of entry matching to given handle</span></div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;<span class="comment">            returns 0 if successful,</span></div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;<span class="comment">            returns 1 if there was no matching entry for given handle, anything remains unchanged</span></div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;            <span class="keyword">inline</span> uint8_t get_callback(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle, <a class="code" href="classfsl_1_1str_1_1union__callback.html">fsl::str::standard_union_callback</a>&amp; callback, <span class="keywordtype">bool</span>&amp; is_callable){</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;                <span class="comment">// callback.set_function_ptr(nullptr); // unchanged</span></div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;                <span class="comment">// is_callable = false; // unchanged</span></div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;                uint8_t index;</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;                macro_interrupt_critical(</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;                index = get_index(handle);</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;                <span class="keywordflow">if</span> (index != TABLE_SIZE) {</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;                    is_callable = table[index].flags.get(ENTRY_CALLABLE);</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;                    callback = table[index].callback;</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;                }</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;                );</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;                <span class="keywordflow">return</span> !(index != TABLE_SIZE);</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;            }</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;            </div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;            <span class="comment">/* execute callback of given handle, if handle is valid and callback is nun-nullptr </span></div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;<span class="comment">            return 0: everything successful</span></div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;<span class="comment">            return 1: no matching entry for given handle, nothing done */</span></div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;            <span class="keyword">inline</span> uint8_t execute_callback(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;                <a class="code" href="classfsl_1_1str_1_1union__callback.html">fsl::str::standard_union_callback</a> callback;</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;                <span class="keywordtype">bool</span> is_callable;</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;                <span class="comment">/*@when here: callback is nullptr. */</span></div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;                <span class="keywordflow">if</span> (get_callback(handle,callback,is_callable)) <span class="keywordflow">return</span> 1;</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;                <a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> local_stack = callback_handle;</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;                callback_handle = handle;</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;                execute_callback&lt;false&gt;(callback,is_callable);</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;                callback_handle = local_stack;</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;                <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;            }</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;            </div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;            <span class="comment">/* delete entry corresponding to given handle (and reorder table)*/</span></div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;            <span class="comment">/* return 0: successful</span></div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;<span class="comment">               return 1: no matching scheduler table entry</span></div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;            <span class="keyword">inline</span> uint8_t clear_entry(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;                macro_interrupt_critical_begin;</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;                uint8_t index = get_index(handle);</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;                <span class="keywordflow">if</span> (index == TABLE_SIZE) {</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;                    macro_interrupt_critical_end;</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;                    <span class="keywordflow">return</span> 1;</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;                }</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;                table[index].flags.set_false(ENTRY_VALID);</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;                <span class="comment">/* reorder table: */</span></div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;                <span class="keywordflow">while</span> ((index != TABLE_SIZE - 1) &amp;&amp; (table[index + 1].flags.get(ENTRY_VALID)) &amp;&amp; (table[index + 1].flags.get(ENTRY_TIMER)) ){</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;                    fsl::util::byte_swap(table[index], table[index+1]);</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;                    ++index;</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;                }</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;                <span class="keywordflow">while</span> ((index != 0) &amp;&amp; (table[index - 1].flags.get(ENTRY_VALID)) &amp;&amp; (table[index + 1].flags.get(ENTRY_TIMER) == <span class="keyword">false</span>) ){</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;                    fsl::util::byte_swap(table[index], table[index-1]);</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;                    --index;</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;                }</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;                macro_interrupt_critical_end;</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;                <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;            }</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;            </div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;            <span class="comment">/* returns true (1) if entry corresponding to handle is enabled, otherwise false (0),</span></div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;<span class="comment">               returns 255 (~true) if no entry matches handle */</span></div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;            <span class="keyword">inline</span> uint8_t get_entry_enable(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;                uint8_t result;</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;                macro_interrupt_critical(</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;                uint8_t index = get_index(handle);</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;                result = (index == TABLE_SIZE) ? 255 : table[index].flags.get(ENTRY_ENABLED);</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;                );</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;                <span class="keywordflow">return</span> result;</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;            }</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;            </div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;            <span class="comment">/* set enable flag of entry corresponding to handle</span></div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;<span class="comment">            return 0: successful</span></div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;<span class="comment">            return 1: no matching entry, aborted</span></div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;            <span class="keyword">inline</span> uint8_t set_entry_enable(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle, <span class="keywordtype">bool</span> enable){</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;                macro_interrupt_critical_begin;</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;                uint8_t index = get_index(handle);</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;                <span class="keywordflow">if</span> (index == TABLE_SIZE) {</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;                    macro_interrupt_critical_end;</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;                    <span class="keywordflow">return</span> 1;</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;                }</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;                table[index].flags.set(ENTRY_ENABLED,enable);</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;                macro_interrupt_critical_end;</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;                <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;            }</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;            </div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;            <span class="comment">/* see description of set_entry_enable */</span></div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;            <span class="keyword">inline</span> uint8_t enable_entry(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){ <span class="keywordflow">return</span> set_entry_enable(handle,<span class="keyword">true</span>); }</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;            </div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;            <span class="comment">/* see description of set_entry_enable */</span></div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;            <span class="keyword">inline</span> uint8_t disable_entry(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){ <span class="keywordflow">return</span> set_entry_enable(handle,<span class="keyword">false</span>); }</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;            </div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;            <span class="comment">/* returns the number of interrupting timers.</span></div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;<span class="comment">               you may call this function from anywhere,</span></div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;<span class="comment">               but call from inside an atomic section, if you want guaranty that no interrupt changes number of int timers in between. */</span></div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;            uint8_t count_int_timers(){</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;                <a class="code" href="classfsl_1_1hw_1_1simple__atomic.html">fsl::hw::simple_atomic</a> atomic; <span class="comment">// open atomic section</span></div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;                uint8_t lower_bound{ 0 };</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;                uint8_t upper_bound{ TABLE_SIZE };</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;                <span class="keywordflow">while</span> (lower_bound != upper_bound){</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;                    <span class="keyword">const</span> uint8_t pivot = (static_cast&lt;uint16_t&gt;(lower_bound) + upper_bound) / 2;</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;                    <span class="keywordflow">if</span> (table[pivot].flags.get(ENTRY_VALID) &amp;&amp; table[pivot].flags.get(ENTRY_TIMER) &amp;&amp; table[pivot].flags.get(ENTRY_INTERRUPTING)){</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;                        lower_bound = pivot + 1;</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;                        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;                        upper_bound = pivot;</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;                    }</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;                }</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;                <span class="keywordflow">return</span> lower_bound;</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;            }</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;            <span class="comment">// &lt;&lt;&lt; to avoid much dups one could use some function for counting table sections, giving some evaluation function that decribes the section.</span></div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;            <span class="comment">// count_entry_section(   bool(scheduler&lt;..&gt;::* evaluator)(uint8_t index)   )</span></div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;            </div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;            <span class="comment">/* returns the number of all timers.</span></div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;<span class="comment">               you may call this function from anywhere,</span></div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;<span class="comment">               but call from inside an atomic section, if you want guaranty that no interrupt changes number of int timers in between. */</span></div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;            uint8_t count_all_timers(){</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;                <a class="code" href="classfsl_1_1hw_1_1simple__atomic.html">fsl::hw::simple_atomic</a> atomic; <span class="comment">// open atomic section</span></div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;                uint8_t lower_bound{ 0 };</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;                uint8_t upper_bound{ TABLE_SIZE };</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;                <span class="keywordflow">while</span> (lower_bound != upper_bound){</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;                    <span class="keyword">const</span> uint8_t pivot = (static_cast&lt;uint16_t&gt;(lower_bound) + upper_bound) / 2;</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;                    <span class="keywordflow">if</span> (table[pivot].flags.get(ENTRY_VALID) &amp;&amp; table[pivot].flags.get(ENTRY_TIMER)){</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;                        lower_bound = pivot + 1;</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;                        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;                        upper_bound = pivot;</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;                    }</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;                }</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;                <span class="keywordflow">return</span> lower_bound;</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;            }</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;            </div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;            <span class="comment">/* returns the number of tasks.</span></div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;<span class="comment">               you may call this function from anywhere,</span></div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;<span class="comment">               but call from inside an atomic section, if you want guaranty that no interrupt changes number of int timers in between. */</span></div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;            uint8_t count_tasks(){</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;                <a class="code" href="classfsl_1_1hw_1_1simple__atomic.html">fsl::hw::simple_atomic</a> atomic; <span class="comment">// open atomic section</span></div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;                uint8_t lower_bound{ 0 };</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;                uint8_t upper_bound{ TABLE_SIZE };</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;                <span class="keywordflow">while</span> (lower_bound != upper_bound){</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;                    <span class="keyword">const</span> uint8_t pivot = (static_cast&lt;uint16_t&gt;(lower_bound) + upper_bound) / 2;</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;                    <span class="keywordflow">if</span> (!(table[pivot].flags.get(ENTRY_VALID) &amp;&amp; (!table[pivot].flags.get(ENTRY_TIMER)))){ <span class="comment">/* not a valid task */</span></div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;                        lower_bound = pivot + 1;</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;                        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;                        upper_bound = pivot;</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;                    }</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;                }</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;                <span class="keywordflow">return</span> TABLE_SIZE - lower_bound;</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;            }</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;            </div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;            <span class="comment">/* returns the number of non-interrupting timers.</span></div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;<span class="comment">               you may call this function from anywhere,</span></div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;<span class="comment">               but call from inside an atomic section, if you want guaranty that no interrupt changes number of int timers in between. */</span></div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;            <span class="keyword">inline</span> uint8_t count_non_int_timers(){  <a class="code" href="classfsl_1_1hw_1_1simple__atomic.html">fsl::hw::simple_atomic</a> atomic; <span class="keywordflow">return</span> count_all_timers()-count_int_timers();    }</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;            <span class="comment">// here we have duplicated simple_atomics because of function calls, maybe create private unsave versions und public save wrappers for functions. &lt;&lt;&lt;&lt;&lt;</span></div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;            </div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;            <span class="comment">/* returns the number of gap lines.</span></div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;<span class="comment">               you may call this function from anywhere,</span></div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;<span class="comment">               but call from inside an atomic section, if you want guaranty that no interrupt changes number of int timers in between. */</span></div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;            <span class="keyword">inline</span> uint8_t count_gaps(){ <a class="code" href="classfsl_1_1hw_1_1simple__atomic.html">fsl::hw::simple_atomic</a> atomic; <span class="keywordflow">return</span> TABLE_SIZE - count_all_timers() - count_tasks(); }</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;            <span class="comment">// here we have duplicated simple_atomics because of function calls, maybe create private unsave versions und public save wrappers for functions. &lt;&lt;&lt;&lt;&lt;</span></div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;            </div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;            <span class="comment">/* returns true iff table is full.</span></div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;<span class="comment">               you may call this function from anywhere,</span></div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;<span class="comment">               but call from inside an atomic section, if you want guaranty that no interrupt changes number of entries in between. */</span></div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">bool</span> table_full(){ <span class="keywordflow">return</span> count_gaps() == 0; }</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;            </div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;            <span class="comment">/* returns true iff table is empty</span></div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;<span class="comment">               you may call this function from anywhere,</span></div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;<span class="comment">               but call from inside an atomic section, if you want guaranty that no interrupt changes number of entries in between. */</span></div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">bool</span> table_empty(){ <span class="keywordflow">return</span> count_gaps() == TABLE_SIZE; }</div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;            </div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;            <span class="comment">/* convert timer to int-timer.</span></div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;<span class="comment">            returns     0:  conversion done without any errors</span></div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;<span class="comment">                        1:  invalid handle, nothing done</span></div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;<span class="comment">                        2:  handle is associated with a task entry</span></div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;<span class="comment">                        4:  handle is already listed as int-timer. no conversion necessary */</span></div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;            uint8_t convert_to_int_timer(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){</div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;                uint8_t error_code{ 0 };</div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;                macro_interrupt_critical(</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;                uint8_t index = get_index(handle);</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;                <span class="keywordflow">if</span> (index == TABLE_SIZE) error_code = 1;</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;                <span class="keywordflow">if</span> (!error_code)    <span class="keywordflow">if</span> (!table[index].flags.get(ENTRY_TIMER)) error_code = 2;</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;                <span class="keywordflow">if</span> (!error_code)    <span class="keywordflow">if</span> (table[index].flags.get(ENTRY_INTERRUPTING)) error_code = 4;</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;                <span class="keywordflow">if</span> (!error_code){</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;                    <span class="keyword">const</span> uint8_t swap { count_int_timers() };</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;                    byte_swap(table[index],table[swap]);</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;                    table[swap].flags.set_true(ENTRY_INTERRUPTING);</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;                }</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;                );</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;                <span class="keywordflow">return</span> error_code;</div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;            }</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;            </div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;            <span class="comment">/* convert timer to non-int-timer.</span></div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;<span class="comment">            returns     0:  conversion done without any errors</span></div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;<span class="comment">                        1:  invalid handle, nothing done</span></div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;<span class="comment">                        2:  handle is associated with a task entry</span></div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;<span class="comment">                        4:  handle is already listed as normal timer. no conversion necessary</span></div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;            uint8_t convert_to_normal_timer(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;                uint8_t error_code{ 0 };</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;                macro_interrupt_critical(</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;                uint8_t index = get_index(handle);</div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;                <span class="keywordflow">if</span> (index == TABLE_SIZE) error_code = 1;</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;                <span class="keywordflow">if</span> (!error_code)    <span class="keywordflow">if</span> (!table[index].flags.get(ENTRY_TIMER)) error_code = 2;</div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;                <span class="keywordflow">if</span> (!error_code)    <span class="keywordflow">if</span> (!table[index].flags.get(ENTRY_INTERRUPTING)) error_code = 4;</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;                <span class="keywordflow">if</span> (!error_code){</div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;                    <span class="keyword">const</span> uint8_t swap { count_int_timers() - 1 };</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;                    byte_swap(table[index],table[swap]);</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;                    table[swap].flags.set_false(ENTRY_INTERRUPTING);</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;                }</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;                );</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;                <span class="keywordflow">return</span> error_code;</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;            }</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;            </div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;            <span class="comment">/* set entry-internal time object pointer to a new time object.</span></div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;<span class="comment">            returns     0:  done without any errors</span></div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;<span class="comment">                        1:  invalid handle, nothing done</span></div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;<span class="comment">                        2:  handle is associated with a task entry</span></div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;            <span class="keyword">inline</span> uint8_t set_event_time_object(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle, <span class="keyword">volatile</span> <a class="code" href="classtime_1_1_extended_metric_time.html">time::ExtendedMetricTime</a>&amp; time_object){</div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;                uint8_t error_code{ 0 };</div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;                macro_interrupt_critical(</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;                uint8_t index = get_index(handle);</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;                <span class="keywordflow">if</span> (index == TABLE_SIZE) error_code = 1;</div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;                <span class="keywordflow">if</span> (!error_code)    <span class="keywordflow">if</span> (!table[index].flags.get(ENTRY_TIMER)) error_code = 2;</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;                <span class="keywordflow">if</span> (!error_code)    {</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;                    table[index].specifics.timer().event_time = &amp;time_object;</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;                    <span class="keywordflow">if</span> ((table[index].flags.get(ENTRY_INTERRUPTING)) &amp;&amp; (table[index].flags.get(ENTRY_ENABLED))){</div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;                        adjust_earliest_interrupting_timer_release(time_object);</div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;                    }</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;                }</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;                );</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;                <span class="keywordflow">return</span> error_code;</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;            }</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;            </div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;            <span class="comment">/* return pointer to time object associated to given timer handle (if possible)</span></div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;<span class="comment">               returns nullptr if there is no valid entry matching handle or matching entry is not of type timer</span></div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;<span class="comment">               You may cast the &#39;const&#39; away of the returned value to modify the time despite this is deprecated,</span></div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;<span class="comment">               but after modifying event_time you should update / reset earliest_interrupting_timer_release in case it is an interrupting timer and you change time to earlier.</span></div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;<span class="comment">               You can do this update by disabling and enabling entry again. Or call reset_int_timer_prefetcher(); .</span></div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;            <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">volatile</span> <a class="code" href="classtime_1_1_extended_metric_time.html">time::ExtendedMetricTime</a>* get_event_time(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;                <span class="keyword">volatile</span> <a class="code" href="classtime_1_1_extended_metric_time.html">time::ExtendedMetricTime</a>* result{ <span class="keyword">nullptr</span> };</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;                <a class="code" href="classfsl_1_1hw_1_1simple__atomic.html">fsl::hw::simple_atomic</a> atomic_section;</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;                uint8_t index = get_index(handle);</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;                <span class="keywordflow">if</span> (index != TABLE_SIZE) <span class="keywordflow">if</span> (table[index].flags.get(ENTRY_TIMER)) result = table[index].specifics.timer().event_time;</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;                <span class="keywordflow">return</span> result;</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;            }</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;            <span class="comment">/* set event time referenced by the entry associated with handle to given time t */</span></div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;            <span class="comment">/* return 0: successful</span></div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;<span class="comment">               return 1: no matching timer entry for given handle */</span></div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;            <span class="keyword">inline</span> uint8_t set_event_time(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle, <span class="keyword">const</span> <a class="code" href="classtime_1_1_extended_metric_time.html">time::ExtendedMetricTime</a>&amp; t){</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;                <span class="keyword">volatile</span> <a class="code" href="classtime_1_1_extended_metric_time.html">time::ExtendedMetricTime</a>* event_time = const_cast&lt;volatile time::ExtendedMetricTime*&gt;(get_event_time(handle));</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;                <span class="keywordflow">if</span> (!event_time) <span class="keywordflow">return</span> 1;</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;                macro_interrupt_critical(</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;                <span class="keywordflow">if</span> (t &lt; *event_time) reset_int_timer_prefetcher();</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;                <span class="comment">// for better performance: just consider the effected table entry and check whether we got an int_timer, if so update earliest_... to min of self and t.</span></div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;                <span class="comment">// this can be easily done as soon as we have accessor objects / (classes). Then this method would become method of timer_entry-specific accessor class.</span></div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;                *event_time = t;</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;                );</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;                <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;            }</div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;            </div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;            <span class="comment">/* resets the earliest_interrupting_timer_release value to its minimum to invoke its calculation by scheduler.</span></div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;<span class="comment">               this function should not be called unless some description tells you to do so. */</span></div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;            <span class="comment">/* &lt;&lt;&lt; as soon as accessor classes are available this method is supposed to become useless. */</span></div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> reset_int_timer_prefetcher(){ earliest_interrupting_timer_release = time::ExtendedMetricTime::MIN(); }</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;            </div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;            <span class="comment">/* returns true if given handle matches to valid task entry */</span></div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_task(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){ <span class="keywordflow">return</span> get_entry_type(handle) == entry_type::TASK; }</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;            </div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;            <span class="comment">/* returns true iff given handle matches to valid non-int timer entry */</span></div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_non_int_timer(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){ <span class="keywordflow">return</span> get_entry_type(handle) == entry_type::TIMER; }</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;            </div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;            <span class="comment">/* returns true iff given handle matches to valid int-timer entry */</span></div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_int_timer(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){ <span class="keywordflow">return</span> get_entry_type(handle) == entry_type::INTTIMER; }</div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;            </div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;            <span class="comment">/* returns true iff given handle matches to valid (int- or non-int) timer entry */</span></div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_any_timer(<a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> handle){ <span class="keywordflow">return</span> is_non_int_timer() || is_int_timer(); }</div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;            <span class="comment">// is inefficient since one flag check would be enough, also get_index will be called twice &lt;&lt;&lt;&lt;&lt;</span></div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;            <span class="comment">// but improving should wait until we have accessor classes that cover this feature method.</span></div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;            </div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;            <span class="comment">/* invalidate all table entries */</span></div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;            <span class="keywordtype">void</span> clear_table(){ macro_interrupt_critical(<span class="keywordflow">for</span>(uint8_t i = 0; i &lt; TABLE_SIZE; ++i) table[i].flags.set_false(ENTRY_VALID);); }</div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;            </div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;            <span class="comment">/* invalidate all task entries */</span></div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> clear_tasks(){ macro_interrupt_critical(<span class="keywordflow">for</span>(uint8_t i = 0; i &lt; TABLE_SIZE; ++i) <span class="keywordflow">if</span> (!table[i].flags.get(ENTRY_TIMER)) table[i].flags.set_false(ENTRY_VALID););}</div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;            </div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;            <span class="comment">/* invalidate all non-int-timer and all int-timer entries */</span></div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> clear_all_timers(){ macro_interrupt_critical(<span class="keywordflow">for</span>(uint8_t i = 0; i &lt; TABLE_SIZE; ++i) <span class="keywordflow">if</span> (table[i].flags.get(ENTRY_TIMER)) table[i].flags.set_false(ENTRY_VALID););}</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;            <span class="comment">/* invalidate all int-timer entries */</span></div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> clear_int_timers(){</div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;                macro_interrupt_critical(</div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;                uint8_t count_int_timer{ count_int_timers() };</div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;                uint8_t count_timer{ count_non_int_timers() };</div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;                <span class="comment">// reorder table and overwrite / delete int_timers :</span></div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;                <span class="keyword">const</span> uint8_t move_size{ fsl::lg::min(count_int_timer, count_timer) };</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;                <span class="keyword">const</span> uint8_t move_src_begin{ count_int_timer + count_timer - move_size };</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;                <span class="keywordflow">for</span>(uint8_t i = 0; i &lt; move_size; ++i){</div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;                    <span class="keyword">const</span> uint8_t src{ move_src_begin + i };</div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;                    table[i] = table[src];</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;                    table[src].flags.set_false(ENTRY_VALID);</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;                }</div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;                );</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;            }</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;</div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;            <span class="comment">/* invalidate all non-int-timer entries */</span></div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> clear_non_int_timers(){ macro_interrupt_critical(<span class="keywordflow">for</span>(uint8_t i = 0; i &lt; TABLE_SIZE; ++i) <span class="keywordflow">if</span> (table[i].flags.get(ENTRY_TIMER) &amp;&amp; (!table[i].flags.get(ENTRY_INTERRUPTING))) table[i].flags.set_false(ENTRY_VALID););}</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;            </div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;            <span class="comment">/* disable all table entries */</span></div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;            <span class="keywordtype">void</span> disable_table(){   macro_interrupt_critical(<span class="keywordflow">for</span>(uint8_t i = 0; i &lt; TABLE_SIZE; ++i) table[i].flags.set_false(ENTRY_ENABLED);); }</div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;            </div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;            <span class="comment">/* disable all task entries */</span></div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> disable_tasks(){ macro_interrupt_critical(<span class="keywordflow">for</span>(uint8_t i = 0; i &lt; TABLE_SIZE; ++i) <span class="keywordflow">if</span> (!table[i].flags.get(ENTRY_TIMER)) table[i].flags.set_false(ENTRY_ENABLED););}</div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;            </div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;            <span class="comment">/* disable all non-int-timer and all int-timer entries */</span></div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> disable_all_timers(){ macro_interrupt_critical(<span class="keywordflow">for</span>(uint8_t i = 0; i &lt; TABLE_SIZE; ++i) <span class="keywordflow">if</span> (table[i].flags.get(ENTRY_TIMER)) table[i].flags.set_false(ENTRY_ENABLED););}</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;            <span class="comment">/* disable all int-timer entries */</span></div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> disable_int_timers(){ macro_interrupt_critical(<span class="keywordflow">for</span>(uint8_t i = 0; i &lt; TABLE_SIZE; ++i) <span class="keywordflow">if</span> (table[i].flags.get(ENTRY_TIMER) &amp;&amp; table[i].flags.get(ENTRY_INTERRUPTING)) table[i].flags.set_false(ENTRY_ENABLED););}</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;            <span class="comment">/* disable all non-int-timer entries */</span></div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> disable_non_int_timers(){ macro_interrupt_critical(<span class="keywordflow">for</span>(uint8_t i = 0; i &lt; TABLE_SIZE; ++i) <span class="keywordflow">if</span> (table[i].flags.get(ENTRY_TIMER) &amp;&amp; (!table[i].flags.get(ENTRY_INTERRUPTING))) table[i].flags.set_false(ENTRY_ENABLED););}</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;            </div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;            <span class="comment">/* enable all task entries */</span></div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> enable_tasks(){ macro_interrupt_critical(<span class="keywordflow">for</span>(uint8_t i = 0; i &lt; TABLE_SIZE; ++i) <span class="keywordflow">if</span> (!table[i].flags.get(ENTRY_TIMER)) table[i].flags.set_true(ENTRY_ENABLED););}</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;            </div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;            <span class="comment">/* executes all stuff that should be done on now_time update, including hardware watchdog reset, int-timer execution e.a.</span></div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;<span class="comment">            should be called once on every update of the now time and only called by interrupt, children function assume interrupt-freedom */</span></div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> time_update_interrupt_handler(){</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;                <span class="keywordflow">if</span> (flags.get(RUNNING)){</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;                    <span class="keywordflow">if</span> ((software_watchdog.get_reset_value() == 0) <span class="comment">/*software watchdog disabled*/</span> || (software_watchdog.value() &gt; 0) <span class="comment">/*software watchdog not exceeded*/</span>)</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;                    {</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;                        --software_watchdog;</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;                        wdt_reset();</div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;                    }</div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;                    <span class="keywordflow">if</span> (flags.get(SOFTWARE_INTERRUPTS_ENABLE) &amp;&amp; (flags.get(STOP_CALLED) == <span class="keyword">false</span>)) execute_interrupting_timers();</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;                }</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;            }</div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;            </div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;            <span class="comment">/* set value of timeout of hardware, use predefined macros WDTO_15MS, WDTO_30MS ... </span></div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;<span class="comment">                stops and starts hardware watchdog to apply change */</span></div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> set_hardware_watchdog_timeout(uint8_t value){</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;                hardware_watchdog_timeout = value;</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;                <span class="keywordflow">if</span> (flags.get(RUNNING)){</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;                    deactivate_hardware_watchdog(); <span class="comment">// &lt;&lt;&lt;&lt; inefficient because twice open and close atomic section, and please check, if it is valid just to do an enable of hw wd (even if it is already enabled) and whether an atomic section is necessary around all of the calls to activate deactivate or reset the watchdog.</span></div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;                    activate_hardware_watchdog();</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;                }</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;            }</div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;            </div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;            <span class="comment">/* deactivates software watchdog</span></div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;<span class="comment">            note that hardware watchdog is still in use and reboots controller if</span></div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;<span class="comment">            * you use too long interrupt timer handlers or</span></div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;<span class="comment">            * you use atomic sections that are far too long</span></div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;<span class="comment">            * if the Scheduler itself would be corrupt and deactivates interrupts for too long</span></div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> deactivate_software_watchdog(){     macro_interrupt_critical(software_watchdog.set_reset_value(0););    }</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;            </div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;            <span class="comment">/* activate the software watchdog for running scheduler.</span></div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;<span class="comment">            software watchdog will be startet when you call run() and stopped before run() returns,</span></div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;<span class="comment">            but may be enabled before you call run() and really should be if you want to have such a software watchdog.</span></div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;<span class="comment">            Set the template parameters this way you want the time to be rounded or use their defaults.</span></div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;<span class="comment">            If any time &lt;= 0 is given the software watchdog will be disabled.</span></div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;            <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> round_to_ceiling = false, <span class="keywordtype">bool</span> truncate = false, <span class="keywordtype">bool</span> truncate_and_add_one = true&gt;</div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> activate_software_watchdog(<span class="keyword">const</span> <a class="code" href="classtime_1_1_extended_metric_time.html">time::ExtendedMetricTime</a>&amp; watchdog){</div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;                static_assert(0 + round_to_ceiling + truncate + truncate_and_add_one == 1, <span class="stringliteral">&quot;There must be one template argument being true and two being false&quot;</span>);</div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;                <span class="keywordflow">if</span> (watchdog &lt;= 0) <span class="keywordflow">return</span> deactivate_software_watchdog();</div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;                macro_interrupt_critical(</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;                <span class="keywordflow">if</span> (round_to_ceiling){ <span class="comment">// constexpr</span></div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;                    software_watchdog.set_reset_value(</div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;                        static_cast&lt;software_watchdog_base_type&gt;(<span class="comment">// &lt;&lt;&lt;&lt; use type as param</span></div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;                            ceil(</div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;                                watchdog.get_in_seconds() * (fsl::os::system_time::get_instance().precision())</div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;                            ) <span class="comment">// &lt;&lt;&lt;&lt;&lt;&lt; what about overflows here ????</span></div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;                        )</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;                    );</div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;                }</div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;                <span class="keywordflow">if</span> (truncate){ <span class="comment">// constexpr</span></div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;                    software_watchdog.set_reset_value(</div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;                        static_cast&lt;software_watchdog_base_type&gt;(</div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;                            watchdog.get_in_seconds() * (fsl::os::system_time::get_instance().precision())</div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;                        )</div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;                    );</div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;                }</div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;                <span class="keywordflow">if</span> (truncate_and_add_one){ <span class="comment">// constexpr</span></div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;                    software_watchdog.set_reset_value(</div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;                        static_cast&lt;software_watchdog_base_type&gt;(</div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;                            watchdog.get_in_seconds() * (fsl::os::system_time::get_instance().precision())</div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;                        )</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;                        + 1</div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;                    );</div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;                }</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;                software_watchdog.reset();</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;                ); <span class="comment">// macro_interrupt_critical</span></div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;                <span class="comment">// &lt;&lt;&lt;&lt;&lt; this function could be written in a different way where we just declare a template function and implement 3 variants with specific set template parameters</span></div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;            }</div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;            </div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;            <span class="comment">/* central control loop / scheduling loop to call after construction  of scheduler, executes all tasks and timers.</span></div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;<span class="comment">            return code:</span></div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;<span class="comment">            0   :   scheduler terminated because of empty table</span></div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;<span class="comment">            1   :   scheduler terminated because of STOP call from inside</span></div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;<span class="comment">            starts the hardware watchdog at the beginning of run() and stops it before run() returns (if it returns)</span></div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;<span class="comment">            hardware watchdog is set up with the hardware_watchdog_timeout.</span></div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;<span class="comment">            Since it activates the hardware watchdog, make sure that the now_time_update_interrupt_handles is called again and again.</span></div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l01075"></a><span class="lineno"><a class="line" href="classfsl_1_1os_1_1scheduler.html#ad707134d03e2028eb598bac3432564a0"> 1075</a></span>&#160;            uint8_t <a class="code" href="classfsl_1_1os_1_1scheduler.html#ad707134d03e2028eb598bac3432564a0">run</a>(){</div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;                static_assert(TABLE_SIZE &gt;= 1, <span class="stringliteral">&quot;Table declared with size 0.&quot;</span>);</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;                flags.set_false(STOP_CALLED); <span class="comment">// delete previous stop command</span></div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;                flags.set_true(RUNNING); <span class="comment">// set running flag</span></div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;                flags.set_false(EMPTY_TABLE_DETECTED); <span class="comment">// check for empty table</span></div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;                activate_hardware_watchdog();</div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;                software_watchdog.reset();<span class="comment">// muss diese zeile in eine crit section???? &lt;&lt;&lt;&lt;&lt;&lt; wo wird der watchdog initialisiert?</span></div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;                </div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;                central_control_loop:</div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;                <span class="keywordflow">while</span>(<span class="keyword">true</span>){</div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;                    </div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;                    uint8_t choice; <span class="comment">// index inside</span></div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;                    macro_interrupt_critical_begin;</div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;                    software_watchdog.reset();</div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;                    </div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;                    <span class="keywordflow">if</span> (flags.get(STOP_CALLED)){</div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;                        <span class="comment">// @when here: while loop must terminated because of a stop() call:</span></div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;                        deactivate_hardware_watchdog();<span class="comment">// wdt_disable(); // stop watchdog</span></div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;                        flags.set_false(RUNNING); <span class="comment">// delete running flag</span></div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;                        macro_interrupt_critical_end;</div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;                        <span class="keywordflow">return</span> 1;</div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;                    }</div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;                    </div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;                    <span class="comment">/*** look for a timer that can be executed ***/</span></div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;                    </div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;                    <a class="code" href="classtime_1_1_extended_metric_time.html">time::ExtendedMetricTime</a> now = fsl::os::system_time::get_instance()();</div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;                    <span class="keywordflow">for</span>(choice = 0; (choice &lt; TABLE_SIZE) &amp;&amp; (! ((table[choice].flags.get(ENTRY_VALID) == <span class="keyword">false</span>) || (table[choice].flags.get(ENTRY_TIMER) == <span class="keyword">false</span>)) ); ++choice){</div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;                        <span class="comment">// at current index we see a valid timer (int or non-int)</span></div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;                        <span class="keywordflow">if</span> (table[choice].flags.get(ENTRY_ENABLED)){</div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;                            <span class="comment">// timer is enabled.</span></div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;                            flags.set_false(EMPTY_TABLE_DETECTED);</div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;                            <span class="keywordflow">if</span> (now &gt; *table[choice].specifics.timer().event_time) {</div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;                                <span class="comment">// timer has expired.</span></div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;                                table[choice].flags.set_false(ENTRY_ENABLED); <span class="comment">// disable timer to avoid execution twice</span></div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;                                <span class="keywordflow">goto</span> execute;</div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;                            }</div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;                        }</div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;                        <span class="comment">// side affect of timer order in table: interrupting timers are always executed first</span></div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;                    }</div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;                    <span class="comment">/*** end of looking for timer ***/</span></div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;                    </div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;                    <span class="comment">// @when here: table may have or may not have timers or may consist only of timers inside, but no of the possibly present timers in table expired</span></div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;                    <span class="comment">// EMPTY_TABLE_DETECTED was set to false when looking through timers if there was at least one enabled timer</span></div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;                    </div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;                    <span class="keywordflow">if</span> (flags.get(EMPTY_TABLE_DETECTED)){ <span class="comment">// table empty, nothing to schedule anymore</span></div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;                        deactivate_hardware_watchdog();</div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;                        flags.set_false(RUNNING);</div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;                        macro_interrupt_critical_end;</div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;                        <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;                    }</div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;                    </div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;                    <span class="comment">/*** look for a task that can be executed ***/</span></div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;                    {</div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;                        <span class="comment">/*</span></div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;<span class="comment">                        different strategies for task selection:</span></div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;<span class="comment">                        </span></div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;<span class="comment">                        -&gt; TIDY_UP_STRATEGY</span></div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;<span class="comment">                        1. go through all task until you find one with 0 racing, replace 0 racing by reset value and choose this task goto execute.</span></div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;<span class="comment">                           remember always the index with lowest racing value.</span></div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;<span class="comment">                        2. [else] if no value == 0 found go through all entries again and subtract the min racing value that was detected.</span></div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;<span class="comment">                           take the one entry with the minimum as choice, reset it to its reset value and execute it.</span></div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;<span class="comment">                        evaluation:</span></div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;<span class="comment">                        =&gt; in up to the half of all cases we wont find 0, =&gt; we go twice through the list, the maybe-only 0 will be shifted away.</span></div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;<span class="comment">                        =&gt; perhaps at next iteration we wont find a 0 again.</span></div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;<span class="comment">                        -&gt; REBASE_WHEN_OVERFLOW_STRATEGY</span></div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;<span class="comment">                        1. alway search for the minimum, global minimum, if found zero we can break earlier.</span></div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;<span class="comment">                           execute this minimum and try to add its distance to its racing value.</span></div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;<span class="comment">                        2. (only) if rancing value is overflowing that we need to go through all entries and make them all smaller.</span></div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;<span class="comment">                        evaluation:</span></div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;<span class="comment">                        =&gt; in comparison to TIDY_UP we still need to do such &quot;subtract x from all entries&quot;, but less often than with TIDY_UP</span></div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;<span class="comment">                        -&gt;  MOVING_ZERO_STRATEGY</span></div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;<span class="comment">                        1. define a static variable last_minimum.</span></div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;<span class="comment">                        2. determine x = argmin{x}{last_minimum + x mod YYY = race_coundown of any task T}</span></div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;<span class="comment">                        3. execute a task which is a witness for x to be argmin.</span></div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;<span class="comment">                        4. set last_minimum = x.</span></div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;<span class="comment">                        evaluation:</span></div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;<span class="comment">                        =&gt; we never need to rebase coundowns</span></div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;<span class="comment">                        =&gt; we always go just once through the whole task section.</span></div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;<span class="comment">                        =&gt; we need one more byte to store last_minimum</span></div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;<span class="comment">                        */</span></div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;</div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;                        uint8_t min_entry_index{ TABLE_SIZE }; <span class="comment">// means no entry</span></div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;                        uint16_t min_entry_race_countdown{ 0xFFFF }; <span class="comment">// means no entry</span></div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;                        </div><div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;                        <span class="keywordflow">for</span> (choice = TABLE_SIZE - 1; (choice &lt; TABLE_SIZE) &amp;&amp; (table[choice].flags.get(ENTRY_VALID) == <span class="keyword">true</span>) &amp;&amp; (table[choice].flags.get(ENTRY_TIMER) == <span class="keyword">false</span>); --choice){</div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;                            <span class="comment">// choice is an index where we see a valid task entry</span></div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;                            <span class="keywordflow">if</span> (table[choice].flags.get(ENTRY_ENABLED)){</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;                                <span class="comment">// current task has to be considered as it is enabled</span></div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;                                <span class="keywordflow">if</span> (table[choice].specifics.task().task_race_countdown == 0){</div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;                                    <span class="keywordflow">goto</span> task_execute;</div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;                                }</div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;                                <span class="keywordflow">if</span> (static_cast&lt;uint16_t&gt;(table[choice].specifics.task().task_race_countdown) &lt; min_entry_race_countdown){</div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;                                    min_entry_index = choice;</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;                                    min_entry_race_countdown = table[choice].specifics.task().task_race_countdown;</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;                                }</div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;                            }</div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;                        }</div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;                        </div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;                        <span class="comment">// @when here: reached end of (maybe empty, maybe max-sized, maybe between) task section, but no task_race_countdown was zero</span></div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;                        </div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;                        <span class="keywordflow">if</span> (min_entry_index == TABLE_SIZE){ <span class="comment">// &lt;==&gt; section has no enabled task &lt;==&gt; task section is called empty (but not 0-sized i.g. because of possibly disabled task entries)</span></div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;                            flags.set_true(EMPTY_TABLE_DETECTED);</div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;                            macro_interrupt_critical_end;</div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;                            <span class="keywordflow">goto</span> central_control_loop; <span class="comment">// the task section is empty at the moment, run scheduler from begin.</span></div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;                        }</div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;                        </div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;                        <span class="comment">// @when here: reached end of non-empty task section (at least one task is valid and enabled), but no task_race_countdown was zero</span></div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;                        </div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;                        <span class="keywordflow">for</span> (choice = TABLE_SIZE - 1; (choice &lt; TABLE_SIZE) &amp;&amp; (table[choice].flags.get(ENTRY_VALID) == <span class="keyword">true</span>) &amp;&amp; (table[choice].flags.get(ENTRY_TIMER) == <span class="keyword">false</span>); --choice){</div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;                            <span class="keywordflow">if</span> (table[choice].flags.get(ENTRY_ENABLED)){</div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;                                table[choice].specifics.task().task_race_countdown -= static_cast&lt;uint8_t&gt;(min_entry_race_countdown);</div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;                            }</div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;                        }</div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;                        choice = min_entry_index;</div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;                        </div><div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;                        task_execute:</div><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;                        table[choice].specifics.task().task_race_countdown = table[choice].specifics.task().task_urgency.inverse_value();</div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;                    }</div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;                    execute:</div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;                    <a class="code" href="classfsl_1_1str_1_1union__callback.html">fsl::str::standard_union_callback</a> callback = table[choice].callback;</div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;                    <a class="code" href="classfsl_1_1lg_1_1range__int.html">handle_type</a> local_stack = callback_handle;</div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;                    callback_handle = table[choice].handle;</div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;                    choice = table[choice].flags.get(ENTRY_CALLABLE);</div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;                    macro_interrupt_critical_end;</div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;                    </div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;                    execute_callback&lt;false&gt;(callback,choice);</div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;                    callback_handle = local_stack;</div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;                }</div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;            }</div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;</div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;            <span class="comment">/* make scheduler return after current executed task / timer */</span></div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> stop(){     macro_interrupt_critical(flags.set_true(STOP_CALLED););     }</div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;</div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;            <span class="comment">/*</span></div><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;<span class="comment">            try to add a new task to the table.</span></div><div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;<span class="comment">            returns SchedulerHandle of created task</span></div><div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;<span class="comment">            if not successful NO_HANDLE is returned. In this case the table is already full with valid entries.</span></div><div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;<span class="comment">            If both possible callback variants are non-nullptr the callable will be preferred.</span></div><div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;            handle_type new_task(<a class="code" href="classfsl_1_1str_1_1callable.html">fsl::str::callable</a>* callable = <span class="keyword">nullptr</span>, fsl::str::void_function <span class="keyword">function</span> = <span class="keyword">nullptr</span>, urgency task_urgency = DEFAULT_URGENCY, <span class="keywordtype">bool</span> enable = <span class="keyword">true</span>){</div><div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;                macro_interrupt_critical_begin;</div><div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;                </div><div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;                uint8_t free_index = new_table_line(<span class="keyword">true</span>,<span class="keyword">false</span>);</div><div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;                <span class="keywordflow">if</span> (free_index == TABLE_SIZE) {</div><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;                    macro_interrupt_critical_end;</div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;                    <span class="keywordflow">return</span> NO_HANDLE;</div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;                }</div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;                <span class="comment">// table[free_index].flags.set_false(ENTRY_ENABLED); this is already the default value coming from new_table_line</span></div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;                <span class="keywordflow">if</span> (enable) table[free_index].flags.set_true(ENTRY_ENABLED);</div><div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;                <span class="comment">// callback and callback flag:</span></div><div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;                <span class="keywordflow">if</span> (callable == <span class="keyword">nullptr</span>){</div><div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;                    table[free_index].callback.set_function_ptr(<span class="keyword">function</span>);</div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;                    table[free_index].flags.set_false(ENTRY_CALLABLE);</div><div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;                    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;                    table[free_index].callback.set_callable_ptr(callable);</div><div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;                    table[free_index].flags.set_true(ENTRY_CALLABLE);</div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;                }</div><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;                <span class="comment">// task specific information: task urgency and countdown:</span></div><div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;                table[free_index].specifics.task().task_urgency = task_urgency;</div><div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;                table[free_index].specifics.task().task_race_countdown = task_urgency.inverse_value(); <span class="comment">// or start with 0;</span></div><div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;                handle_type free_handle = table[free_index].handle;</div><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;                macro_interrupt_critical_end;</div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;                <span class="keywordflow">return</span> free_handle;</div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;            }</div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;            </div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;            <span class="comment">/* creates a new timer entry.</span></div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;<span class="comment">            for the event_time, the scheduler only saves a pointer to the given time object.</span></div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;<span class="comment">            You have to provide a time object in its memory space yourself in the background.</span></div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;<span class="comment">            returns NO_HANDLE if table was already full, then table was not modified.</span></div><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;<span class="comment">            otherwise: returns handle of created timer.</span></div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;<span class="comment">            If both, callable and void_function are non-null, the callable will be preferred */</span></div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;            handle_type new_timer(<span class="keyword">volatile</span> <a class="code" href="classtime_1_1_extended_metric_time.html">time::ExtendedMetricTime</a>&amp; time, <a class="code" href="classfsl_1_1str_1_1callable.html">fsl::str::callable</a>* callable = <span class="keyword">nullptr</span>, fsl::str::void_function <span class="keyword">function</span> = <span class="keyword">nullptr</span>, <span class="keywordtype">bool</span> is_interrupting = <span class="keyword">false</span>, <span class="keywordtype">bool</span> enable = <span class="keyword">true</span>){</div><div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;                macro_interrupt_critical_begin;</div><div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;                </div><div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;                uint8_t free_index = new_table_line(<span class="keyword">false</span>,is_interrupting);</div><div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;                <span class="keywordflow">if</span> (free_index == TABLE_SIZE){</div><div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;                    macro_interrupt_critical_end;</div><div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;                    <span class="keywordflow">return</span> NO_HANDLE;</div><div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;                }</div><div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;                <span class="comment">// some flags:</span></div><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;                <span class="keywordflow">if</span> (enable) table[free_index].flags.set_true(ENTRY_ENABLED);</div><div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;                </div><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;                <span class="comment">// callback and callback flag:</span></div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;                <span class="keywordflow">if</span> (callable == <span class="keyword">nullptr</span>){</div><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;                    table[free_index].callback.set_function_ptr(<span class="keyword">function</span>);</div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;                    table[free_index].flags.set_false(ENTRY_CALLABLE);</div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;                    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;                    table[free_index].callback.set_callable_ptr(callable);</div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;                    table[free_index].flags.set_true(ENTRY_CALLABLE);</div><div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;                }</div><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;                <span class="comment">// timer specific information: timer event time</span></div><div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;                table[free_index].specifics.timer().event_time = &amp;time;</div><div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;                <span class="keywordflow">if</span> (is_interrupting) adjust_earliest_interrupting_timer_release(time);</div><div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;                handle_type free_handle = table[free_index].handle;</div><div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;                macro_interrupt_critical_end;</div><div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;                <span class="keywordflow">return</span> free_handle;</div><div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;            }</div><div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;            </div><div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;            <span class="comment">/* returns the handle of the first disabled valid entry in table (returns NO_HANDLE iff there is no such entry)</span></div><div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;<span class="comment">            writes the first [min(count@before, count@after)] handles with the outlined property (ENTRY_VALID and not ENTRY_ENABLE) into the [handle_array].</span></div><div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;<span class="comment">            [count@before] determines the array size provided by the calling instance.</span></div><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;<span class="comment">            After function return [count@after] is the number of entries in table with the outlined property.</span></div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;            handle_type get_disabled_entries(uint8_t&amp; count, handle_type* handle_array = <span class="keyword">nullptr</span>){</div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;                <span class="keywordflow">if</span> (handle_array == <span class="keyword">nullptr</span>) count = 0;</div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;                handle_type return_value = NO_HANDLE;</div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;                macro_interrupt_critical(</div><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;                uint8_t counter{ 0 }; <span class="comment">// next free array position</span></div><div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;                <span class="keywordflow">for</span>(uint8_t index = 0; index &lt; TABLE_SIZE; ++index){</div><div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;                    <span class="keywordflow">if</span> (table[index].flags.get(ENTRY_VALID) &amp;&amp; !table[index].flags.get(ENTRY_ENABLED)){</div><div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;                        <span class="keywordflow">if</span> (counter &lt; count){</div><div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;                            handle_array[counter] = table[index].handle;</div><div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;                        }</div><div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;                        <span class="keywordflow">if</span> (counter == 0){</div><div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;                            return_value = table[index].handle;</div><div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;                        }</div><div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;                        ++counter;</div><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;                    }</div><div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;                }</div><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;                count = counter;</div><div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;                );</div><div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;                <span class="keywordflow">return</span> return_value;</div><div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;            }</div><div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;            </div><div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;            </div><div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;            <span class="comment">/*** static assertions ***/</span></div><div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;            </div><div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;            static_assert(<span class="keyword">sizeof</span>(handle_type) == 1, <span class="stringliteral">&quot;SchedulerHandle has not the appropriate size.&quot;</span>);</div><div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;            static_assert(<span class="keyword">sizeof</span>(<a class="code" href="classfsl_1_1str_1_1union__callback.html">fsl::str::standard_union_callback</a>) == 2, <span class="stringliteral">&quot;UnionCallback has not the appropriate size.&quot;</span>);</div><div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;            static_assert(<span class="keyword">sizeof</span>(union_specifics) == 2, <span class="stringliteral">&quot;UnionSpecifics has not the appropriate size.&quot;</span>);</div><div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;            static_assert(<span class="keyword">sizeof</span>(<a class="code" href="classfsl_1_1lg_1_1flags.html">fsl::lg::single_flags</a>) == 1, <span class="stringliteral">&quot;fsl::lg::single_flags has not the appropriate size.&quot;</span>);</div><div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;            static_assert(<span class="keyword">sizeof</span>(entry) == 6, <span class="stringliteral">&quot;SchedulerMemoryLine has not the appropriate size.&quot;</span>);</div><div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;<span class="comment">/*</span></div><div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;<span class="comment">            class table_entry_accessor : private fsl::hw::simple_atomic {</span></div><div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;<span class="comment">                inline table_entry_accessor(handle_type handle) : fsl::hw::simple_atomic() { }</span></div><div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;<span class="comment">                </span></div><div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;<span class="comment">                uint8_t table_index;</span></div><div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;<span class="comment">                public:</span></div><div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;<span class="comment">                static fsl::str::exceptional&lt;table_entry_accessor, void&gt; get_table_entry(handle_type handle){}</span></div><div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;<span class="comment">                    // this is dangerous: if you use an union overlapping two classes. which of the destructors will be called?</span></div><div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;<span class="comment">                    // the one will deal with SREG the other one might overwrite the sreg-copy.</span></div><div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;<span class="comment">                    </span></div><div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;<span class="comment">                void set_callback(){</span></div><div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;<span class="comment">                    </span></div><div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;<span class="comment">                }</span></div><div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;<span class="comment">            };</span></div><div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;<span class="comment">            class Task_Entry : Table_Entry {</span></div><div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;<span class="comment">                </span></div><div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;<span class="comment">                public:</span></div><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;<span class="comment">                </span></div><div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;<span class="comment">                </span></div><div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;<span class="comment">            };</span></div><div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;<span class="comment">            class Timer_Entry : Table_Entry {</span></div><div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;<span class="comment">                </span></div><div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;<span class="comment">            };</span></div><div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;        };</div><div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;        </div><div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;    }</div><div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;}</div><div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;</div><div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;</div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;<span class="preprocessor">#endif //__SCHEDULER_H__</span></div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;</div><div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;</div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;<span class="comment">/******** REFACTORING ISSUES **************/</span></div><div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;<span class="comment">/*</span></div><div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;<span class="comment">-2. Think about inlining.</span></div><div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;<span class="comment">-1. Add all reasons for including the include files.</span></div><div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;<span class="comment">-0.5 there are different strategies for task selection in method run(). just implement the other ones and compare or make it possible to decide by conditioned compilation.</span></div><div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;<span class="comment">-0. implement accessor classes to avoid the multiple duplications in functions like $598</span></div><div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;<span class="comment">--100.  try unordered tyble layout:</span></div><div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;<span class="comment">    // advantages:</span></div><div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;<span class="comment">    // -&gt;   much work to find free handles</span></div><div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;<span class="comment">    //      use indices as handles, less memory consumption for table (1 byte per line)     &lt;-</span></div><div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;<span class="comment">    // disadvantages:</span></div><div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;<span class="comment">    //  searching in method run() will take more time, I think                              &lt;-</span></div><div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;<span class="comment">*/</span></div><div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;</div><div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;</div><div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;<span class="comment">/************************************************************************/</span></div><div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;<span class="comment">/* ideas for new features                                                 </span></div><div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;<span class="comment">- int-timers may be executed with an int-call or with an non-int-call</span></div><div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;<span class="comment">  we may add an entry-wise flag INT-CALL-ONLY to deny non-int calls on int-timers</span></div><div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;<span class="comment">  (some programmers might use it if they want actions to be executed in certain time intervals</span></div><div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;<span class="comment">  and don&#39;t want such a procedure to come earlier than the next system_time_update. </span></div><div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;<span class="comment">  </span></div><div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;<span class="comment">- task entries may get an additional flag that determines whether the task need some kind of finalization,</span></div><div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;<span class="comment">  if you want do shutdown the controller.</span></div><div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;<span class="comment">  So it might be possible to define such a flag and offer besides the stop() method of the scheduler another</span></div><div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;<span class="comment">  function shutdown() which first executes all tasks that have a positive fincalization flag once and stop scheduling right after.</span></div><div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;<span class="comment">- There is the possibility to find out whether a controller reset was caused by exceeding watchdog or not.</span></div><div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;<span class="comment">  (beim ATmega16 z. B. Bit WDRF in MCUCSR). Diese Information sollte auch genutzt werden, falls ein WD-Reset in der Anwendung nicht planmig implementiert wurde. Zum Beispiel kann man eine LED an einen freien Pin hngen, die nur bei einem Reset durch den WD aufleuchtet oder aber das &quot;Ereignis WD-Reset&quot; im internen EEPROM des AVR absichern, um die Information spter z. B. ber UART oder ein Display auszugeben (oder einfach den EEPROM-Inhalt ber die ISP/JTAG-Schnittstelle auslesen).</span></div><div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;<span class="comment">  Bei neueren AVR-Typen bleibt der Watchdog auch nach einem Reset durch den Watchdog aktiviert. Wenn ein Programm nach dem Neustart bis zur erstmaligen Rckstellung des Watchdogs lnger braucht, als die im Watchdog eingestellte Zeit, sollte man den Watchdog explizit mglichst frh deaktivieren. Ansonsten resetet der Watchdog den Controller immerfort von Neuem. Die frhe Deaktivierung sollte durch eine Funktion erfolgen, die noch vor allen anderen Operationen (insbesondere vor dem mglw. lnger andauernden internen Initialisierungen vor dem Sprung zu main()) ausgefhrt wird. Nheres zur Implementierung mit avr-gcc/avr-libc findet sich in der Dokumentation der avr-libc (Suchbegriffe: attribut, section, init).</span></div><div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;<span class="comment">  fsl::os sollte diesen wert auslesen, os loader sollte hw wd zuerst deaktivieren.</span></div><div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;<span class="comment">  */</span></div><div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;<span class="comment">/************************************************************************/</span></div><div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;</div><div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;</div><div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;<span class="comment">/************************************************************************/</span></div><div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;<span class="comment">/* testing issues:</span></div><div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;<span class="comment">check whether interrupt handling needs more time than the system_time precision!!!!</span></div><div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;<span class="comment">at bottom of function time_update_interrupt_handler.</span></div><div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;<span class="comment">                                                                     */</span></div><div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;<span class="comment">/************************************************************************/</span></div><div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;</div><div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;</div><div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;<span class="comment">/************************************************************************/</span></div><div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;<span class="comment">/* checking issues:</span></div><div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;<span class="comment">  there should be mo option to read a callback, and execute it</span></div><div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;<span class="comment">  outside the context of the scheduler since [my_handle] would not be correct</span></div><div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;<span class="comment">                                                                       */</span></div><div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;<span class="comment">/************************************************************************/</span></div><div class="ttc" id="classfsl_1_1hw_1_1simple__atomic_html"><div class="ttname"><a href="classfsl_1_1hw_1_1simple__atomic.html">fsl::hw::simple_atomic</a></div><div class="ttdef"><b>Definition:</b> f_interrupt.h:118</div></div>
<div class="ttc" id="classfsl_1_1os_1_1scheduler_html_ad707134d03e2028eb598bac3432564a0"><div class="ttname"><a href="classfsl_1_1os_1_1scheduler.html#ad707134d03e2028eb598bac3432564a0">fsl::os::scheduler::run</a></div><div class="ttdeci">uint8_t run()</div><div class="ttdef"><b>Definition:</b> f_scheduler.h:1075</div></div>
<div class="ttc" id="classfsl_1_1os_1_1urgency_html"><div class="ttname"><a href="classfsl_1_1os_1_1urgency.html">fsl::os::urgency</a></div><div class="ttdef"><b>Definition:</b> f_urgency.h:17</div></div>
<div class="ttc" id="classfsl_1_1os_1_1scheduler_html"><div class="ttname"><a href="classfsl_1_1os_1_1scheduler.html">fsl::os::scheduler</a></div><div class="ttdef"><b>Definition:</b> f_scheduler.h:71</div></div>
<div class="ttc" id="classfsl_1_1str_1_1callable_html"><div class="ttname"><a href="classfsl_1_1str_1_1callable.html">fsl::str::callable</a></div><div class="ttdef"><b>Definition:</b> f_callbacks.h:17</div></div>
<div class="ttc" id="classfsl_1_1str_1_1union__callback_html"><div class="ttname"><a href="classfsl_1_1str_1_1union__callback.html">fsl::str::union_callback</a></div><div class="ttdef"><b>Definition:</b> f_callbacks.h:28</div></div>
<div class="ttc" id="classfsl_1_1lg_1_1flags_html"><div class="ttname"><a href="classfsl_1_1lg_1_1flags.html">fsl::lg::flags</a></div><div class="ttdef"><b>Definition:</b> f_flags.h:87</div></div>
<div class="ttc" id="classfsl_1_1lg_1_1countdown_html"><div class="ttname"><a href="classfsl_1_1lg_1_1countdown.html">fsl::lg::countdown&lt; software_watchdog_base_type &gt;</a></div></div>
<div class="ttc" id="classfsl_1_1lg_1_1range__int_html"><div class="ttname"><a href="classfsl_1_1lg_1_1range__int.html">fsl::lg::range_int&lt; uint8_t, TABLE_SIZE, true, true &gt;</a></div></div>
<div class="ttc" id="classtime_1_1_extended_metric_time_html"><div class="ttname"><a href="classtime_1_1_extended_metric_time.html">time::ExtendedMetricTime</a></div><div class="ttdef"><b>Definition:</b> f_time.h:266</div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
